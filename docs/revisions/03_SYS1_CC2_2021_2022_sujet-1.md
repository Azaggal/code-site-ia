Voici la fiche d'analyse structur√©e pour l'annale **03_SYS1_CC2_2021_2022_sujet-1**, conforme aux instructions fournies :

---

# 03_SYS1_CC2_2021_2022_sujet-1 üìÑ
**üìÑ PDF original** : [03_SYS1_CC2_2021_2022_sujet-1.pdf](./annales/03_SYS1_CC2_2021_2022_sujet-1.pdf)

---

### üéØ **ANALYSE GLOBALE**
!!! note "üìä Statistiques"
    - **Th√®mes abord√©s** :
      - Architecture des processeurs (30% : caches, registres, assembleur x86-64)
      - Langage C (40% : pointeurs, m√©moire, compilation)
      - Syst√®mes et librairies (20% : shared libraries, passage de param√®tres)
      - D√©bogage (10% : questions ouvertes)
    - **Types de questions** : QCM (20 questions), questions ouvertes (2 probl√®mes)
    - **Pi√®ges fr√©quents** :
      - Confusion entre `rbp` et `rsp` en assembleur.
      - Comportement des pointeurs et arithm√©tique m√©moire en C.

---

### üß© **QUESTIONS D√âTAILL√âES**

!!! example "üî¢ Question 1 : Hi√©rarchie des caches"
    **√ânonc√© original** :
    > Laquelle des assertions suivantes est-elle vraie ?
    > - Un cache L1 est plus rapide qu‚Äôun cache L2.
    > - Un cache L2 est plus rapide qu‚Äôun cache L1.

    !!! success "üü¢ Solution"
        1. **M√©thode** : Connaissance de la hi√©rarchie m√©moire (Cours 2, ¬ß1.3).
        2. **√âtapes** :
           - Le cache L1 est plus proche du CPU et plus petit ‚Üí **plus rapide**.
           - Le cache L2 est plus grand mais plus lent.
        3. **R√©sultat** : `$oxed{\text{Un cache L1 est plus rapide qu‚Äôun cache L2}}$`

    !!! tip "üí° Liens utiles"
        - **Cours associ√©** : "Architecture des processeurs" (Chapitre 2)
        - **TD similaire** : TD1, Exercice 3 (hi√©rarchie m√©moire)
        - **Points cl√©s** : L1 > L2 > L3 en vitesse.

    !!! warning "‚ö†Ô∏è Pi√®ges"
        - **Erreur classique** : Confondre taille et vitesse.
        - **Conseil** : M√©moriser "Plus proche = plus rapide".

---

!!! example "üî¢ Question 2 : R√©servation de m√©moire sur la pile (x86-64)"
    **√ânonc√© original** :
    > Comment r√©server 16 octets (10h en hexad√©cimal) sur la pile en assembleur x86 64 bits ?
    > - `add rbp,10h`
    > - `add rsp,10h`
    > - `sub rbp,10h`
    > - `sub rsp,10h`

    !!! success "üü¢ Solution"
        1. **M√©thode** : Manipulation du pointeur de pile (`rsp`) (Cours 3, ¬ß2.1).
        2. **√âtapes** :
           - La pile cro√Æt vers les adresses **basses** ‚Üí utiliser `sub`.
           - `rsp` pointe vers le sommet de la pile (pas `rbp`).
        3. **R√©sultat** : `$oxed{\text{sub rsp,10h}}$`

    !!! tip "üí° Liens utiles"
        - **Cours associ√©** : "Assembleur x86-64" (Chapitre 3)
        - **TD similaire** : TD2, Exercice 1 (manipulation de pile)
        - **Points cl√©s** : `rsp` = sommet de pile, `sub` pour r√©server.

    !!! warning "‚ö†Ô∏è Pi√®ges"
        - **Erreur classique** : Utiliser `rbp` au lieu de `rsp`.
        - **Conseil** : Dessiner la pile pour visualiser.

---

!!! example "üî¢ Question 9 : Endianness et pointeurs en C"
    **√ânonc√© original** :
    > On consid√®re l‚Äôextrait de code en C suivant :
    > ```c
    > int16_t i = 10;
    > char* ptr_i = (char*)&i;
    > ptr_i[0] = 2;
    > printf("%i\n", (int)i);
    > ```
    > Quelle sortie produit cet extrait sur un processeur Intel x86 ?

    !!! success "üü¢ Solution"
        1. **M√©thode** : Endianness et manipulation de pointeurs (Cours 4, ¬ß3.2).
        2. **√âtapes** :
           - `int16_t` = 2 octets. Sur x86 (little-endian), l'octet de poids faible est √† l'adresse basse.
           - `ptr_i[0]` modifie l'octet de poids faible ‚Üí `i` devient `0x020A` (522 en d√©cimal).
        3. **R√©sultat** : `$oxed{522}$`

    !!! tip "üí° Liens utiles"
        - **Cours associ√©** : "Repr√©sentation des donn√©es" (Chapitre 4)
        - **TD similaire** : TD3, Exercice 4 (endianness)
        - **Points cl√©s** : Little-endian = poids faible en premier.

---

!!! example "üî¢ Question 21 : Boucle en assembleur (bug)"
    **√ânonc√© original** :
    > Pourquoi le code suivant n‚Äôimprime qu‚Äôune seule fois le message ?
    > ```asm
    > mov rax, 0
    > begin:
    >   mov rax, 1  ; syscall write
    >   mov rdi, 1  ; stdout
    >   mov rsi, message
    >   mov rdx, msgLen
    >   syscall
    >   inc rax
    >   cmp rax, 5
    >   jl begin
    > ```

    !!! success "üü¢ Solution"
        1. **Probl√®me** :
           - `rax` est √©cras√© par le `syscall` (retourne le nombre d'octets √©crits).
           - La condition `cmp rax, 5` compare donc le r√©sultat du `syscall` (toujours 11 ici) √† 5.
        2. **Corrections propos√©es** :
           - **Solution 1 (variable .data)** :
             ```asm
             SECTION .data
             counter: db 0
             SECTION .text
             mov byte [counter], 0
             begin:
               ; ... syscall ...
               inc byte [counter]
               cmp byte [counter], 5
               jl begin
             ```
           - **Solution 2 (pile)** :
             ```asm
             push 0
             begin:
               ; ... syscall ...
               pop rax
               inc rax
               push rax
               cmp rax, 5
               jl begin
             ```

    !!! tip "üí° Liens utiles"
        - **Cours associ√©** : "Appels syst√®me en assembleur" (Chapitre 5)
        - **TD similaire** : TD4, Exercice 2 (boucles en assembleur)
        - **Points cl√©s** : Les `syscall` modifient `rax`.

---

### üìä **SYNTH√àSE POUR LA R√âVISION**
!!! note "üìå √Ä retenir"
    - **Top 3 des concepts tomb√©s** :
      1. Manipulation de la pile en assembleur (`rsp`, `rbp`).
      2. Pointeurs et endianness en C.
      3. Hi√©rarchie m√©moire (caches, registres).
    - **1 question type √† ma√Ætriser** : Q9 (endianness) ou Q21 (boucles en assembleur).
    - **1 m√©thode r√©utilisable** :
      - Pour les QCM : **√©liminer les r√©ponses absurdes** (ex: "10 octets pour L1" ‚Üí faux).
      - Pour les questions ouvertes : **sch√©matiser la pile/m√©moire** avant de coder.

---

### üîç **Remarques g√©n√©rales**
- **Points faibles r√©currents** :
  - Confusion entre `rsp` et `rbp` (Q2, Q10).
  - Oubli de l'endianness (Q9).
  - Mauvaise gestion des registres apr√®s un `syscall` (Q21).
- **Strat√©gie de r√©vision** :
  - **Pratique** : Refaire les TDs d'assembleur (TD2) et de C (TD3).
  - **Th√©orie** : Relire les chapitres sur la m√©moire (Cours 2 et 4).