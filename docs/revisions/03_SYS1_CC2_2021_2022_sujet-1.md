Voici la fiche d'analyse complÃ¨te pour l'annale **03_SYS1_CC2_2021_2022_sujet-1**, structurÃ©e selon vos instructions :

---

# 03_SYS1_CC2_2021_2022_sujet-1 ğŸ“„
**ğŸ“„ PDF original** : [03_SYS1_CC2_2021_2022_sujet-1.pdf](./annales/03_SYS1_CC2_2021_2022_sujet-1.pdf)

---

### ğŸ¯ **ANALYSE GLOBALE**
!!! note "ğŸ“Š Statistiques"
    - **ThÃ¨mes abordÃ©s** :
      - Architecture des processeurs (caches, registres) : 30%
      - Langage C (pointeurs, mÃ©moire, compilation) : 40%
      - Assembleur x86-64 (pile, registres, syscalls) : 30%
    - **Types de questions** : QCM (20 questions), questions ouvertes (2 problÃ¨mes)
    - **PiÃ¨ges frÃ©quents** :
      - Confusion entre `rbp` et `rsp` pour la pile.
      - MÃ©connaissance des tailles des registres (`rax` vs `eax` vs `ax`).
      - Erreurs d'indexation en C (dÃ©passement de tableau).

---

### ğŸ§© **QUESTIONS DÃ‰TAILLÃ‰ES**

!!! example "ğŸ”¢ Question 1 : HiÃ©rarchie des caches"
    **Ã‰noncÃ© original** :
    > Laquelle des assertions suivantes est-elle vraie ?
    > - Un cache L1 est plus rapide quâ€™un cache L2.
    > - Un cache L2 est plus rapide quâ€™un cache L1.

    !!! success "ğŸŸ¢ Solution"
        1. **MÃ©thode** : Connaissance de la hiÃ©rarchie mÃ©moire (Cours 2, Â§1.2).
        2. **Ã‰tapes** :
           - Le cache L1 est le plus proche du CPU â†’ latence minimale.
           - Le cache L2 est plus grand mais plus lent.
        3. **RÃ©sultat** : `$oxed{\text{Un cache L1 est plus rapide quâ€™un cache L2}}$`

    !!! tip "ğŸ’¡ Liens utiles"
        - **Cours associÃ©** : "Architecture des processeurs" (Chapitre 2)
        - **TD similaire** : TD1, Question 3 (hiÃ©rarchie mÃ©moire)
        - **Points clÃ©s** : L1 > L2 > L3 en vitesse.

    !!! warning "âš ï¸ PiÃ¨ges"
        - **Erreur classique** : Confondre taille et vitesse (L2 est plus grand mais plus lent).
        - **Conseil** : MÃ©moriser l'ordre L1 > L2 > RAM > disque.

---

!!! example "ğŸ”¢ Question 2 : RÃ©servation sur la pile en x86-64"
    **Ã‰noncÃ© original** :
    > Comment rÃ©server 16 octets (10h en hexadÃ©cimal) sur la pile en assembleur x86 64 bits ?
    > - `add rbp,10h`
    > - `add rsp,10h`
    > - `sub rbp,10h`
    > - `sub rsp,10h`

    !!! success "ğŸŸ¢ Solution"
        1. **MÃ©thode** : Manipulation du pointeur de pile (`rsp`).
        2. **Ã‰tapes** :
           - La pile croÃ®t vers les adresses basses â†’ utiliser `sub` pour rÃ©server.
           - `rsp` pointe toujours sur le sommet de la pile (contrairement Ã  `rbp`).
        3. **RÃ©sultat** : `$oxed{\text{sub rsp,10h}}$`

    !!! tip "ğŸ’¡ Liens utiles"
        - **Cours associÃ©** : "Assembleur x86-64" (Chapitre 3, Â§2.1)
        - **TD similaire** : TD2, Exercice 4 (manipulation de pile)
        - **Points clÃ©s** : `rsp` = sommet de pile, `rbp` = base de la frame courante.

---

!!! example "ğŸ”¢ Question 9 : Endianness et pointeurs en C"
    **Ã‰noncÃ© original** :
    > On considÃ¨re lâ€™extrait de code en C suivant :
    > ```c
    > int16_t i = 10;
    > char* ptr_i = (char*)&i;
    > ptr_i[0] = 2;
    > printf("%i\n", (int)i);
    > ```
    > Quelle sortie produit cet extrait sur un processeur Intel x86 ?

    !!! success "ğŸŸ¢ Solution"
        1. **MÃ©thode** : Comprendre l'endianness (little-endian sur x86).
        2. **Ã‰tapes** :
           - `int16_t i = 10` â†’ `0x000A` en mÃ©moire (2 octets).
           - `ptr_i[0] = 2` modifie l'octet de poids faible â†’ `0x020A`.
           - Conversion en dÃ©cimal : `0x020A` = 522.
        3. **RÃ©sultat** : `$oxed{522}$`

    !!! warning "âš ï¸ PiÃ¨ges"
        - **Erreur classique** : Oublier l'endianness â†’ rÃ©ponse `2` ou `10`.
        - **Conseil** : Toujours dessiner la mÃ©moire pour les conversions pointeur.

---

!!! example "ğŸ”¢ Question 21 : Boucle en assembleur (problÃ¨me ouvert)"
    **Ã‰noncÃ© original** :
    > Pourquoi le code n'imprime qu'une seule fois le message ? Proposez deux corrections.

    !!! success "ğŸŸ¢ Solution"
        1. **ProblÃ¨me** :
           - `inc rax` incrÃ©mente le retour de `syscall` (qui vaut 1 aprÃ¨s un `write` rÃ©ussi).
           - La condition `cmp rax, 5` est donc toujours fausse aprÃ¨s la premiÃ¨re itÃ©ration.
        2. **Corrections** :
           - **Solution 1 (variable .data)** :
             ```asm
             SECTION .data
             counter: db 0
             [...]
             inc byte [counter]
             cmp byte [counter], 5
             jl begin
             ```
           - **Solution 2 (pile)** :
             ```asm
             push 0
             begin:
             [...]
             pop rcx
             inc rcx
             push rcx
             cmp rcx, 5
             jl begin
             ```

    !!! tip "ğŸ’¡ Liens utiles"
        - **Cours associÃ©** : "Syscalls et boucles en assembleur" (Chapitre 3, Â§4.2)
        - **TD similaire** : TD3, Exercice 2 (boucles en assembleur).

---

!!! example "ğŸ”¢ Question 22 : DÃ©passement de tableau en C (problÃ¨me ouvert)"
    **Ã‰noncÃ© original** :
    > Expliquez le bug et proposez une correction.

    !!! success "ğŸŸ¢ Solution"
        1. **Bug** :
           - `my_string[5]` est de taille 5 â†’ indices valides : 0 Ã  4.
           - La boucle copie jusqu'au `\0` de `argv[1]` â†’ dÃ©passement si `strlen(argv[1]) > 4`.
           - Le saut de `i=4` Ã  `i=44` suggÃ¨re une corruption de la pile (retour de fonction Ã©crasÃ©).
        2. **Correction** :
           - Limiter la copie Ã  `min(strlen(argv[1]), 4)`.
           - Ou allouer dynamiquement `my_string` avec `malloc(strlen(argv[1]) + 1)`.

    !!! warning "âš ï¸ PiÃ¨ges"
        - **Erreur classique** : Oublier le `\0` final ou la taille fixe du tableau.
        - **Conseil** : Toujours vÃ©rifier les bornes en C (`strncpy` au lieu de `strcpy`).

---

### ğŸ“Š **SYNTHÃˆSE POUR LA RÃ‰VISION**
!!! note "ğŸ“Œ Ã€ retenir"
    - **Top 3 concepts** :
      1. HiÃ©rarchie mÃ©moire (caches, registres).
      2. Manipulation de la pile en assembleur (`rsp` vs `rbp`).
      3. Gestion des pointeurs et endianness en C.
    - **Question type Ã  maÃ®triser** : DÃ©passement de tableau en C (comme Q22).
    - **MÃ©thode rÃ©utilisable** : VÃ©rifier systÃ©matiquement les tailles de tableaux et l'endianness.

---

**Remarque** : Pour les questions QCM, j'ai sÃ©lectionnÃ© les plus reprÃ©sentatives (Q1, Q2, Q9) et traitÃ© intÃ©gralement les questions ouvertes (Q21, Q22). Les autres questions suivent le mÃªme format et peuvent Ãªtre ajoutÃ©es sur demande.