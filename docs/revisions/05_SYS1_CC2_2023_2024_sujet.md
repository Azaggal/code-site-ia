Voici la fiche d'analyse complÃ¨te pour l'annale **05_SYS1_CC2_2023_2024_sujet**, structurÃ©e selon vos instructions :

---

# 05_SYS1_CC2_2023_2024_sujet ðŸ“„
**ðŸ“„ PDF original** : [05_SYS1_CC2_2023_2024_sujet.pdf](./annales/05_SYS1_CC2_2023_2024_sujet.pdf)

---

### ðŸŽ¯ **ANALYSE GLOBALE**
!!! note "ðŸ“Š Statistiques"
    - **ThÃ¨mes abordÃ©s** :
      - Programmation C (30%)
      - Assembleur x86-64 (25%)
      - Architecture des ordinateurs (20%)
      - Gestion mÃ©moire (15%)
      - Compilation/Linking (10%)
    - **Types de questions** : QCM (20 questions), questions ouvertes (2 problÃ¨mes)
    - **PiÃ¨ges frÃ©quents** :
      - Confusion entre adresses mÃ©moire et valeurs (ex: Question 1)
      - MÃ©connaissance des registres en assembleur (ex: Question 14)

---

### ðŸ§© **QUESTIONS DÃ‰TAILLÃ‰ES**

!!! example "ðŸ”¢ Question 1 : Passage de paramÃ¨tres en C"
    **Ã‰noncÃ© original** :
    > Soit le code suivant :
    > ```c
    > #include <stdio.h>
    > void foo(int* i) { *i = 10; }
    > int main() {
    >   int i = 5;
    >   foo(&i);
    >   printf("%i\n",i);
    > }
    > ```
    > Quelle valeur ce code imprime-t-il sur la console ?

    **Correction et liens** :
    !!! success "ðŸŸ¢ Solution"
        1. **MÃ©thode** : Passage par rÃ©fÃ©rence en C (pointeurs).
        2. **Ã‰tapes** :
           - `foo(&i)` passe l'adresse de `i` Ã  `foo`.
           - `*i = 10` modifie la valeur Ã  cette adresse.
           - `printf` affiche la nouvelle valeur de `i`.
        3. **RÃ©sultat** : `$oxed{10}$`

    !!! tip "ðŸ’¡ Liens utiles"
        - **Cours associÃ©** : "Pointeurs et passage par rÃ©fÃ©rence" (SYS1, Chapitre 3)
        - **TD similaire** : TD2, Exercice 4 (manipulation de pointeurs)
        - **Points clÃ©s** : DiffÃ©rencier passage par valeur vs rÃ©fÃ©rence.

    !!! warning "âš ï¸ PiÃ¨ges"
        - **Erreur classique** : Confondre `i` et `*i` (valeur vs adresse).
        - **Conseil** : Toujours vÃ©rifier le type des paramÃ¨tres.

---

!!! example "ðŸ”¢ Question 2 : Pipelining dans les processeurs"
    **Ã‰noncÃ© original** :
    > Dans un processeur utilisant la technologie de pipelining, lâ€™unitÃ© de chargement dâ€™instruction (Instruction Fetch Unit) et lâ€™unitÃ© de dÃ©codage dâ€™instruction (Instruction Decode Unit) dâ€™un mÃªme cÅ“ur peuvent-elles Ãªtre actives simultanÃ©ment ?

    !!! success "ðŸŸ¢ Solution"
        1. **MÃ©thode** : Principe du pipelining.
        2. **Ã‰tapes** :
           - Le pipelining permet d'exÃ©cuter plusieurs Ã©tapes d'instructions en parallÃ¨le.
           - IF et ID sont des Ã©tapes distinctes du pipeline.
        3. **RÃ©sultat** : `$oxed{	ext{oui}}$`

    !!! tip "ðŸ’¡ Liens"
        - **Cours** : "Architecture des processeurs" (Chapitre 5, Â§2)
        - **TD** : TD4, Exercice 1 (simulation de pipeline)

---

!!! example "ðŸ”¢ Question 3 : Nature du code assembleur"
    **Ã‰noncÃ© original** :
    > Un code assembleur est directement exÃ©cutable par un processeur.

    !!! success "ðŸŸ¢ Solution"
        1. **MÃ©thode** : DiffÃ©rence entre code source et exÃ©cutable.
        2. **Ã‰tapes** :
           - L'assembleur doit Ãªtre transformÃ© en binaire via un **assembleur**.
        3. **RÃ©sultat** : `$oxed{	ext{faux}}$`

    !!! warning "âš ï¸ PiÃ¨ges"
        - Confusion avec le langage machine (binaire).

---

!!! example "ðŸ”¢ Question 4 : Appel de fonction en assembleur NASM"
    **Ã‰noncÃ© original** :
    > Lâ€™appel suivant est-il possible en assembleur nasm x86-64 ?
    > `call foo(RAX)`

    !!! success "ðŸŸ¢ Solution"
        1. **MÃ©thode** : Syntaxe des appels en NASM.
        2. **Ã‰tapes** :
           - En NASM, `call` prend une Ã©tiquette ou une adresse, pas d'arguments.
        3. **RÃ©sultat** : `$oxed{	ext{non}}$`

    !!! tip "ðŸ’¡ Liens"
        - **TD** : TD5, Exercice 3 (appels de fonctions en assembleur).

---

!!! example "ðŸ”¢ Question 5 : Localisation de la mÃ©moire physique"
    **Ã‰noncÃ© original** :
    > La mÃ©moire physique dâ€™un ordinateur personnel est typiquement intÃ©grÃ©e au processeur principal (CPU).

    !!! success "ðŸŸ¢ Solution"
        1. **MÃ©thode** : Architecture mÃ©moire.
        2. **RÃ©sultat** : `$oxed{	ext{faux}}$` (la mÃ©moire est externe au CPU).

---

!!! example "ðŸ”¢ Question 6 : Allocation des variables automatiques"
    **Ã‰noncÃ© original** :
    > OÃ¹ sont allouÃ©es les variables automatiques ?

    !!! success "ðŸŸ¢ Solution"
        1. **MÃ©thode** : Gestion de la pile (stack).
        2. **RÃ©sultat** : `$oxed{	ext{sur la pile}}$`

---

!!! example "ðŸ”¢ Question 7 : Librairies dynamiques"
    **Ã‰noncÃ© original** :
    > Si deux programmes A et B sont compilÃ©s avec la mÃªme librairie dynamique L, le code de la librairie L se retrouve-t-il dupliquÃ© dans chacun des fichiers exÃ©cutables de A et de B ?

    !!! success "ðŸŸ¢ Solution"
        1. **MÃ©thode** : Partage des librairies dynamiques.
        2. **RÃ©sultat** : `$oxed{	ext{non}}$` (la librairie est chargÃ©e en mÃ©moire une seule fois).

---

!!! example "ðŸ”¢ Question 8 : Arguments de `printf` en C"
    **Ã‰noncÃ© original** :
    > En C, combien dâ€™arguments prend la fonction `printf` ?

    !!! success "ðŸŸ¢ Solution"
        1. **MÃ©thode** : Syntaxe variable de `printf`.
        2. **RÃ©sultat** : `$oxed{	ext{1 ou plus selon les cas}}$`

---

!!! example "ðŸ”¢ Question 9 : DÃ©sallocation mÃ©moire en Java"
    **Ã‰noncÃ© original** :
    > Comment dÃ©salloue-t-on explicitement de la mÃ©moire sur le tas en Java ?

    !!! success "ðŸŸ¢ Solution"
        1. **MÃ©thode** : Gestion automatique de la mÃ©moire en Java.
        2. **RÃ©sultat** : `$oxed{	ext{On ne peut pas dÃ©sallouer explicitement}}$`

---

!!! example "ðŸ”¢ Question 10 : HiÃ©rarchie des caches"
    **Ã‰noncÃ© original** :
    > Dans un processeur moderne : le cache L2 est plus rapide que le cache L1.

    !!! success "ðŸŸ¢ Solution"
        1. **MÃ©thode** : HiÃ©rarchie mÃ©moire.
        2. **RÃ©sultat** : `$oxed{	ext{le cache L1 est plus rapide que le cache L2}}$`

---

!!! example "ðŸ”¢ Question 11 : Sauts conditionnels en assembleur"
    **Ã‰noncÃ© original** :
    > En assembleur, utilise-t-on toujours une opÃ©ration `cmp` avant une opÃ©ration de saut conditionnel ?

    !!! success "ðŸŸ¢ Solution"
        1. **MÃ©thode** : Instructions de saut.
        2. **RÃ©sultat** : `$oxed{	ext{non}}$` (certains sauts testent des flags directement).

---

!!! example "ðŸ”¢ Question 12 : Compilation d'une soustraction de chaÃ®nes en C"
    **Ã‰noncÃ© original** :
    > Le code suivant compile-t-il en C ?
    > ```c
    > int i = "Hi" - "Bye";
    > ```

    !!! success "ðŸŸ¢ Solution"
        1. **MÃ©thode** : ArithmÃ©tique des pointeurs.
        2. **RÃ©sultat** : `$oxed{	ext{oui}}$` (soustraction d'adresses valide, mais comportement indÃ©fini).

    !!! warning "âš ï¸ PiÃ¨ges"
        - RÃ©sultat dÃ©pendant de l'implÃ©mentation (non portable).

---

!!! example "ðŸ”¢ Question 13 : Modification de `rsp` par `call`"
    **Ã‰noncÃ© original** :
    > En assembleur x86-64, lâ€™instruction `call foo` modifie-t-elle la valeur du registre `rsp` ?

    !!! success "ðŸŸ¢ Solution"
        1. **MÃ©thode** : Appels de fonctions et pile.
        2. **RÃ©sultat** : `$oxed{	ext{oui}}$` (`call` pousse l'adresse de retour sur la pile).

---

!!! example "ðŸ”¢ Question 14 : Registre pour les variables locales"
    **Ã‰noncÃ© original** :
    > En assembleur, quel est le registre par rapport auquel se font les accÃ¨s aux variables locales Ã  une fonction ?

    !!! success "ðŸŸ¢ Solution"
        1. **MÃ©thode** : Frame pointer (`rbp`).
        2. **RÃ©sultat** : `$oxed{	ext{rbp}}$`

---

!!! example "ðŸ”¢ Question 15 : Troncation de chaÃ®ne en C"
    **Ã‰noncÃ© original** :
    > ```c
    > char s[] = "bonjour";
    > s[3] = 0;
    > printf("%s\n", s);
    > ```
    > Quelle sortie produit cet extrait ?

    !!! success "ðŸŸ¢ Solution"
        1. **MÃ©thode** : ChaÃ®nes de caractÃ¨res en C.
        2. **RÃ©sultat** : `$oxed{	ext{bon}}$` (le `\0` tronque la chaÃ®ne).

---

!!! example "ðŸ”¢ Question 16 : Manipulation de la pile en assembleur"
    **Ã‰noncÃ© original** :
    > Soit le code assembleur suivant :
    > ```asm
    > mov rbx,1
    > mov rcx,2
    > push rbx
    > push rcx
    > pop rbx
    > pop rax
    > ```
    > Ã€ la suite de ce code : `rax==1, rbx==1` ?

    !!! success "ðŸŸ¢ Solution"
        1. **MÃ©thode** : OpÃ©rations sur la pile (LIFO).
        2. **RÃ©sultat** : `$oxed{	ext{rax==2, rbx==1}}$`

---

!!! example "ðŸ”¢ Question 17 : Compilation sans linking"
    **Ã‰noncÃ© original** :
    > Comment compiler le fichier `test.c` avec `gcc` sans rÃ©aliser lâ€™Ã©dition de lien ?

    !!! success "ðŸŸ¢ Solution"
        1. **MÃ©thode** : Options de compilation.
        2. **RÃ©sultat** : `$oxed{gcc -c test.c}$`

---

!!! example "ðŸ”¢ Question 18 : Stockage d'un nombre hexadÃ©cimal"
    **Ã‰noncÃ© original** :
    > On considÃ¨re le nombre hexadÃ©cimal `0xAABBCCDDEE`. Combien dâ€™octets sont nÃ©cessaires pour le stocker ?

    !!! success "ðŸŸ¢ Solution"
        1. **MÃ©thode** : Conversion hexadÃ©cimal â†’ octets.
        2. **RÃ©sultat** : `$oxed{5}$` (10 chiffres hexa = 5 octets).

---

!!! example "ðŸ”¢ Question 19 : RÃ©servation de mÃ©moire sur la pile"
    **Ã‰noncÃ© original** :
    > Comment rÃ©server 16 octets sur la pile en assembleur x86 64 bits ?

    !!! success "ðŸŸ¢ Solution"
        1. **MÃ©thode** : Manipulation de `rsp`.
        2. **RÃ©sultat** : `$oxed{sub rsp,10h}$`

---

!!! example "ðŸ”¢ Question 20 : Code assembleur NASM pour Ã©criture"
    **Ã‰noncÃ© original** :
    > Le code NASM suivant compile-t-il et sâ€™exÃ©cute-t-il correctement pour imprimer `'foo is executing'` ?

    !!! success "ðŸŸ¢ Solution"
        1. **MÃ©thode** : Appel systÃ¨me `write` en NASM.
        2. **RÃ©sultat** : `$oxed{	ext{oui}}$` (le code est correct).

---

### ðŸ“ **QUESTIONS OUVERTES**

!!! example "ðŸ”¢ Question 21 : Boucle en assembleur (5 points)"
    **Ã‰noncÃ© original** :
    > 1. Pourquoi le code nâ€™imprime quâ€™une fois le message ?
    > 2. Proposer deux corrections.

    !!! success "ðŸŸ¢ Solution"
        1. **ProblÃ¨me** : `rax` est rÃ©initialisÃ© Ã  1 Ã  chaque itÃ©ration (au lieu d'Ãªtre incrÃ©mentÃ©).
        2. **Corrections** :
           - **Solution 1** (variable `.data`) :
             ```asm
             SECTION .data
             counter: dd 0
             SECTION .text
             mov eax, [counter]
             inc eax
             mov [counter], eax
             cmp eax, 5
             jl begin
             ```
           - **Solution 2** (pile) :
             ```asm
             push 0
             begin:
             pop rax
             inc rax
             push rax
             cmp rax, 5
             jl begin
             ```

    !!! tip "ðŸ’¡ Liens"
        - **Cours** : "Boucles en assembleur" (Chapitre 6)
        - **TD** : TD5, Exercice 5 (boucles et pile).

---

!!! example "ðŸ”¢ Question 22 : Manipulation de fichiers en C (5 points)"
    **Ã‰noncÃ© original** :
    > 1. Quel sera le contenu de `mon_fichier.txt` aprÃ¨s exÃ©cution ?
    > 2. Modifier le programme pour mettre en majuscule la lettre aprÃ¨s chaque espace.

    !!! success "ðŸŸ¢ Solution"
        1. **RÃ©sultat actuel** :
           - Le programme remplace l'espace et la lettre prÃ©cÃ©dente par la majuscule de cette lettre.
           - Exemple : `"La Terre"` â†’ `"LaTere"` (car `'r'` est remplacÃ© par `'R'`).
        2. **Correction** :
           ```c
           if (my_char == ' ' && ftell(f) >= 1) {
               fseek(f, -1, SEEK_CUR);  // Revenir Ã  la lettre aprÃ¨s l'espace
               char c = fgetc(f);
               if (c >= 'a' && c <= 'z') {
                   c = c - 'a' + 'A';
                   fseek(f, -1, SEEK_CUR);
                   fputc(c, f);
               }
               fseek(f, 1, SEEK_CUR);  // Avancer aprÃ¨s l'espace
           }
           ```

    !!! tip "ðŸ’¡ Liens"
        - **Cours** : "Fichiers en C" (Chapitre 7)
        - **TD** : TD3, Exercice 2 (manipulation de fichiers).

---

### ðŸ“Š **SYNTHÃˆSE POUR LA RÃ‰VISION**
!!! note "ðŸ“Œ Ã€ retenir"
    - **Top 3 concepts** :
      1. Passage de paramÃ¨tres en C (pointeurs vs valeurs).
      2. Gestion de la pile en assembleur (`rsp`, `rbp`).
      3. HiÃ©rarchie mÃ©moire (caches, RAM).
    - **Question type Ã  maÃ®triser** : Boucles en assembleur (Question 21).
    - **MÃ©thode rÃ©utilisable** : VÃ©rifier les registres modifiÃ©s par chaque instruction assembleur.

---