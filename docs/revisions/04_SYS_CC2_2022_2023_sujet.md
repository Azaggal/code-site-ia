Voici la fiche d'analyse complÃ¨te pour l'annale **ESIR SYS1 CC2 2022â€“2023**, structurÃ©e selon vos instructions :

---

# 04_SYS_CC2_2022_2023_sujet ðŸ“„
**ðŸ“„ PDF original** : [04_SYS_CC2_2022_2023_sujet.pdf](./annales/04_SYS_CC2_2022_2023_sujet.pdf)

---

### ðŸŽ¯ **ANALYSE GLOBALE**
!!! note "ðŸ“Š Statistiques"
    - **ThÃ¨mes abordÃ©s** :
      - Assembleur x86-64 (30%)
      - Gestion mÃ©moire (tas/pile, segments) (25%)
      - Compilation et linkage (20%)
      - EntrÃ©es/sorties et fichiers (15%)
      - Architecture processeur (10%)
    - **Types de questions** : QCM (20 questions), questions ouvertes (2 questions avec sous-parties)
    - **PiÃ¨ges frÃ©quents** :
      - Confusion entre registres 32/64 bits (ex: `ecx` vs `rcx`)
      - Modes d'ouverture de fichiers en C (`"w"` vs `"a"`)
      - Allocation mÃ©moire (variables automatiques vs tas)

---

### ðŸ§© **QUESTIONS DÃ‰TAILLÃ‰ES**

!!! example "ðŸ”¢ Question 1 : Sortie d'un programme assembleur NASM"
    **Ã‰noncÃ© original** :
    > Quel est le rÃ©sultat du programme assembleur NASM suivant ? (Le caractÃ¨re ASCII 10 est un retour Ã  la ligne.)
    ```nasm
    SECTION .data
    message: db 'HELLO WORLD!',10
    len: equ $-message
    SECTION .text
    GLOBAL _start
    _start:
        mov rsi, 0
    loop:
        cmp BYTE [message+rsi], '!'
        je end
        add BYTE [message+rsi], 'a'-'A'
        inc rsi
        jmp loop
    end:
        ; ... (syscalls pour Ã©crire et quitter)
    ```

    !!! success "ðŸŸ¢ Solution"
        1. **MÃ©thode** : Analyse pas Ã  pas de la boucle.
        2. **Ã‰tapes** :
            - La boucle convertit chaque caractÃ¨re de `message` en minuscule (sauf `'!'` qui termine la boucle).
            - `'H' + ('a'-'A') = 'h'`, `'E' + 32 = 'e'`, etc.
            - Le `'!'` final reste inchangÃ©.
        3. **RÃ©sultat** : `$oxed{	ext{hello world!}}$` (avec retour Ã  la ligne).

    !!! tip "ðŸ’¡ Liens utiles"
        - **Cours associÃ©** : "Assembleur x86-64" (Chapitre 2, manipulation de chaÃ®nes)
        - **TD similaire** : TD1, Exercice 3 (boucles en assembleur)
        - **Points clÃ©s** :
          - `add BYTE [message+rsi], 'a'-'A'` : conversion majuscule â†’ minuscule.
          - `cmp` + `je` : condition de sortie.

    !!! warning "âš ï¸ PiÃ¨ges"
        - **Erreur classique** : Oublier que `'a'-'A'` vaut 32 (diffÃ©rence ASCII).
        - **Conseil** : Tracer la boucle avec un exemple (ex: `'H'` â†’ `'h'`).

---

!!! example "ðŸ”¢ Question 2 : LibÃ©ration mÃ©moire en C"
    **Ã‰noncÃ© original** :
    > Quelle fonction C permet de libÃ©rer de la mÃ©moire allouÃ©e sur le tas ?

    !!! success "ðŸŸ¢ Solution"
        1. **RÃ©ponse** : `free`.
        2. **Explication** :
            - `malloc`/`calloc` allouent sur le tas.
            - `free` libÃ¨re cette mÃ©moire.

    !!! tip "ðŸ’¡ Liens"
        - **Cours** : "Gestion mÃ©moire en C" (Chapitre 3, Â§2)
        - **TD** : TD2, Exercice 1 (allocation dynamique)

    !!! warning "âš ï¸ PiÃ¨ges"
        - **Erreur** : Confondre `delete` (C++) avec `free` (C).

---

!!! example "ðŸ”¢ Question 3 : Taille du registre `ecx`"
    **Ã‰noncÃ© original** :
    > Sur combien de bits fonctionne le registre `ecx` en x86-64 ?

    !!! success "ðŸŸ¢ Solution"
        1. **RÃ©ponse** : 32 bits.
        2. **Explication** :
            - En x86-64, `ecx` est la version 32 bits de `rcx` (64 bits).
            - `cx` = 16 bits, `cl` = 8 bits.

    !!! tip "ðŸ’¡ Liens"
        - **Cours** : "Registres x86-64" (Chapitre 1, Â§4)
        - **TD** : TD1, Question 5 (noms des registres)

---

!!! example "ðŸ”¢ Question 4 : Pipelining"
    **Ã‰noncÃ© original** :
    > Dans un processeur avec pipelining, l'unitÃ© de chargement d'instruction (IF) et l'unitÃ© de dÃ©codage (ID) peuvent-elles Ãªtre actives simultanÃ©ment ?

    !!! success "ðŸŸ¢ Solution"
        1. **RÃ©ponse** : Oui.
        2. **Explication** :
            - Le pipelining permet d'exÃ©cuter plusieurs Ã©tapes d'instructions en parallÃ¨le (ex: IF pour l'instruction N+1 pendant que ID traite l'instruction N).

    !!! tip "ðŸ’¡ Liens"
        - **Cours** : "Architecture des processeurs" (Chapitre 5, Â§3)
        - **TD** : TD3, Exercice 2 (pipelining)

---

!!! example "ðŸ”¢ Question 5 : BibliothÃ¨ques dynamiques"
    **Ã‰noncÃ© original** :
    > Faut-il recompiler un exÃ©cutable si une bibliothÃ¨que dynamique qu'il utilise est modifiÃ©e ?

    !!! success "ðŸŸ¢ Solution"
        1. **RÃ©ponse** : Non.
        2. **Explication** :
            - Les bibliothÃ¨ques dynamiques (`.so`) sont chargÃ©es Ã  l'exÃ©cution. La modification de la bibliothÃ¨que n'affecte pas l'exÃ©cutable.

    !!! tip "ðŸ’¡ Liens"
        - **Cours** : "Linkage et bibliothÃ¨ques" (Chapitre 4, Â§1)
        - **TD** : TD4, Exercice 3 (bibliothÃ¨ques statiques vs dynamiques)

---

!!! example "ðŸ”¢ Question 6 : Ã‰criture dans un fichier en C"
    **Ã‰noncÃ© original** :
    > Le code suivant est-il correct pour Ã©crire "Hello World!" dans `mon_fichier.txt` ?
    ```c
    fprintf("mon_fichier.txt", "Hello World!");
    ```

    !!! success "ðŸŸ¢ Solution"
        1. **RÃ©ponse** : Non.
        2. **Correction** :
            - `fprintf` prend d'abord un `FILE*` (obtenu via `fopen`), puis la chaÃ®ne de format.
            - Code correct :
              ```c
              FILE *f = fopen("mon_fichier.txt", "w");
              fprintf(f, "Hello World!");
              fclose(f);
              ```

    !!! warning "âš ï¸ PiÃ¨ges"
        - **Erreur** : Inverser les arguments de `fprintf`.

---

!!! example "ðŸ”¢ Question 7 : Bytecode Java"
    **Ã‰noncÃ© original** :
    > Le bytecode Java est-il directement exÃ©cutable par un processeur ?

    !!! success "ðŸŸ¢ Solution"
        1. **RÃ©ponse** : Faux.
        2. **Explication** :
            - Le bytecode Java est interprÃ©tÃ© par la JVM (Java Virtual Machine), qui le traduit en instructions machine.

---

!!! example "ðŸ”¢ Question 8 : Prologue de fonction en assembleur"
    **Ã‰noncÃ© original** :
    > Ã€ quoi correspondent les instructions `push rbp; mov rbp, rsp` ?

    !!! success "ðŸŸ¢ Solution"
        1. **RÃ©ponse** : Au prologue d'une fonction.
        2. **Explication** :
            - `push rbp` : Sauvegarde le pointeur de base de la fonction appelante.
            - `mov rbp, rsp` : Initialise le nouveau pointeur de base pour la fonction courante.

    !!! tip "ðŸ’¡ Liens"
        - **Cours** : "Appels de fonctions en assembleur" (Chapitre 2, Â§5)
        - **TD** : TD1, Exercice 4 (prologue/Ã©pilogue)

---

!!! example "ðŸ”¢ Question 9 : Fichier binaire vs texte"
    **Ã‰noncÃ© original** :
    > Le code suivant produit-il un fichier binaire ou texte ?
    ```c
    unsigned int temperatures[] = {8,10,17,5,20};
    fwrite(temperatures, sizeof(unsigned int), 5, f);
    ```

    !!! success "ðŸŸ¢ Solution"
        1. **RÃ©ponse** : Un fichier binaire.
        2. **Explication** :
            - `fwrite` Ã©crit les donnÃ©es brutes (4 octets par `unsigned int`), sans conversion texte.

---

!!! example "ðŸ”¢ Question 10 : HiÃ©rarchie des caches"
    **Ã‰noncÃ© original** :
    > Quelle assertion est vraie ?
    - Un cache L2 est plus rapide qu'un cache L1.
    - Un cache L1 est plus rapide qu'un cache L2.

    !!! success "ðŸŸ¢ Solution"
        1. **RÃ©ponse** : Un cache L1 est plus rapide qu'un cache L2.
        2. **Explication** :
            - L1 est plus proche du CPU et plus petit (donc plus rapide).

---

!!! example "ðŸ”¢ Question 11 : Variables automatiques"
    **Ã‰noncÃ© original** :
    > OÃ¹ sont allouÃ©es les variables automatiques ?

    !!! success "ðŸŸ¢ Solution"
        1. **RÃ©ponse** : Sur la pile (stack).
        2. **Explication** :
            - Les variables locales (automatiques) sont gÃ©rÃ©es par la pile.

---

!!! example "ðŸ”¢ Question 12 : ExÃ©cutabilitÃ© du code assembleur"
    **Ã‰noncÃ© original** :
    > Un code assembleur est-il directement exÃ©cutable par un processeur ?

    !!! success "ðŸŸ¢ Solution"
        1. **RÃ©ponse** : Vrai.
        2. **Explication** :
            - L'assembleur produit du code machine directement exÃ©cutable (aprÃ¨s linkage).

---

!!! example "ðŸ”¢ Question 13 : Mode d'ouverture de fichier en C"
    **Ã‰noncÃ© original** :
    > Quel mode permet d'ajouter des donnÃ©es Ã  un fichier sans l'Ã©craser ?

    !!! success "ðŸŸ¢ Solution"
        1. **RÃ©ponse** : `"a"`.
        2. **Explication** :
            - `"a"` = append (ajout Ã  la fin).
            - `"w"` = Ã©crasement, `"r+"` = lecture/Ã©criture.

---

!!! example "ðŸ”¢ Question 14 : Contenu des bibliothÃ¨ques partagÃ©es dans un exÃ©cutable"
    **Ã‰noncÃ© original** :
    > Le contenu de `libfoo.so` est-il inclus dans l'exÃ©cutable `a.out` ?

    !!! success "ðŸŸ¢ Solution"
        1. **RÃ©ponse** : Non.
        2. **Explication** :
            - Les bibliothÃ¨ques dynamiques sont chargÃ©es Ã  l'exÃ©cution (pas incluses dans l'exÃ©cutable).

---

!!! example "ðŸ”¢ Question 15 : Stockage de la variable `i`"
    **Ã‰noncÃ© original** :
    > OÃ¹ est stockÃ©e la variable `i` dans ce code ?
    ```c
    int i = 6;
    int main() { i = i + 3; }
    ```

    !!! success "ðŸŸ¢ Solution"
        1. **RÃ©ponse** : Dans le segment de donnÃ©es (data segment).
        2. **Explication** :
            - Variables globales/statitiques â†’ segment `.data` ou `.bss`.

---

!!! example "ðŸ”¢ Question 16 : Compilation sans linkage"
    **Ã‰noncÃ© original** :
    > Comment compiler `test.c` sans rÃ©aliser l'Ã©dition de lien ?

    !!! success "ðŸŸ¢ Solution"
        1. **RÃ©ponse** : `gcc -c test.c`.
        2. **Explication** :
            - `-c` gÃ©nÃ¨re un fichier objet (`.o`) sans linker.

---

!!! example "ðŸ”¢ Question 17 : Symboles non dÃ©finis dans un exÃ©cutable"
    **Ã‰noncÃ© original** :
    > Un exÃ©cutable utilisant une bibliothÃ¨que partagÃ©e contient-il des symboles non dÃ©finis ?

    !!! success "ðŸŸ¢ Solution"
        1. **RÃ©ponse** : Oui.
        2. **Explication** :
            - Les symboles des bibliothÃ¨ques dynamiques sont marquÃ©s `U` (undefined) dans `nm`.

---

!!! example "ðŸ”¢ Question 18 : DÃ©sallocation de variables automatiques"
    **Ã‰noncÃ© original** :
    > Peut-on dÃ©sallouer explicitement une variable automatique ?

    !!! success "ðŸŸ¢ Solution"
        1. **RÃ©ponse** : Non.
        2. **Explication** :
            - Les variables automatiques sont gÃ©rÃ©es par la pile (dÃ©sallouÃ©es automatiquement Ã  la sortie du bloc).

---

!!! example "ðŸ”¢ Question 19 : Mise Ã  jour de bibliothÃ¨ques partagÃ©es"
    **Ã‰noncÃ© original** :
    > Un exÃ©cutable peut-il utiliser une bibliothÃ¨que partagÃ©e compilÃ©e plus rÃ©cemment ?

    !!! success "ðŸŸ¢ Solution"
        1. **RÃ©ponse** : Oui, c'est possible.
        2. **Explication** :
            - Les bibliothÃ¨ques dynamiques sont chargÃ©es Ã  l'exÃ©cution (compatibilitÃ© ABI requise).

---

!!! example "ðŸ”¢ Question 20 : Appel de fonction en assembleur NASM"
    **Ã‰noncÃ© original** :
    > L'appel `call foo(10,20)` est-il possible en NASM x86-64 ?

    !!! success "ðŸŸ¢ Solution"
        1. **RÃ©ponse** : Non.
        2. **Explication** :
            - NASM utilise la convention d'appel System V (passage des arguments via registres/stack, pas de syntaxe `foo(10,20)`).

---

### ðŸ“ **PARTIE OUVERTE**

!!! example "ðŸ”¢ Question 21 : Passage de paramÃ¨tre en C"
    **Ã‰noncÃ© original** :
    > Quel type de passage de paramÃ¨tre le compilateur a-t-il utilisÃ© pour `foo(5)` ?

    !!! success "ðŸŸ¢ Solution"
        1. **RÃ©ponse** : Passage par registre (`edi`).
        2. **Preuves** :
            - `mov edi, 0x5` : Le paramÃ¨tre `5` est passÃ© via `edi` (convention System V x86-64).
            - Le code source montre un appel rÃ©cursif avec `i-1` (passÃ© de la mÃªme maniÃ¨re).

    !!! tip "ðŸ’¡ Liens"
        - **Cours** : "Appels de fonctions en C" (Chapitre 3, Â§4)
        - **TD** : TD2, Exercice 4 (conventions d'appel)

---

!!! example "ðŸ”¢ Question 22 : Analyse du code dÃ©compilÃ© de `foo`"
    **Sous-questions** :

    !!! example "(a) Prologue de la fonction"
        **Ã‰noncÃ©** :
        > Comment s'appellent les trois premiÃ¨res instructions ? Ã€ quoi servent-elles ?

        !!! success "ðŸŸ¢ Solution"
            1. **Instructions** :
                - `push rbp` : Sauvegarde le pointeur de base de la fonction appelante.
                - `mov rbp, rsp` : Initialise le nouveau pointeur de base pour `foo`.
                - `sub rsp, 0x10` : Alloue 16 octets sur la pile pour les variables locales.
            2. **Nom** : Prologue de fonction.

    !!! example "(b) Stockage de la variable `i`"
        **Ã‰noncÃ©** :
        > OÃ¹ est stockÃ©e la variable `i` ?

        !!! success "ðŸŸ¢ Solution"
            1. **RÃ©ponse** : Sur la pile (stack).
            2. **Preuve** :
                - `mov DWORD PTR [rbp-0x4], edi` : `i` est stockÃ©e Ã  `rbp-4` (4 octets sur la pile).

    !!! example "(c) ImplÃ©mentation du `if`"
        **Ã‰noncÃ©** :
        > Quelles instructions implÃ©mentent le `if` ?

        !!! success "ðŸŸ¢ Solution"
            1. **Instructions** :
                - `cmp DWORD PTR [rbp-0x4], 0x0` : Compare `i` Ã  0.
                - `jle 1169 <foo+0x34>` : Saute Ã  la fin si `i <= 0`.
                - `sub eax, 0x1` + `mov edi, eax` + `call 1135 <foo>` : Appel rÃ©cursif si `i > 0`.

---

### ðŸ“Š **SYNTHÃˆSE POUR LA RÃ‰VISION**
!!! note "ðŸ“Œ Ã€ retenir"
    - **Top 3 concepts** :
      1. **Assembleur x86-64** : Registres, conventions d'appel, prologue/Ã©pilogue.
      2. **Gestion mÃ©moire** : Tas vs pile, segments (data/BSS/stack), allocation dynamique.
      3. **Compilation/linkage** : BibliothÃ¨ques statiques vs dynamiques, symboles non dÃ©finis.
    - **1 question type Ã  maÃ®triser** : Analyse de code assembleur (ex: Question 1 ou 22).
    - **1 mÃ©thode rÃ©utilisable** :
      - Pour les QCM : Ã‰liminer les rÃ©ponses impossibles (ex: `delete` n'existe pas en C).
      - Pour les questions ouvertes : Lier chaque instruction assembleur Ã  son Ã©quivalent en C.

---