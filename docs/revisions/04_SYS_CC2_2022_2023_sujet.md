Voici la fiche d'analyse d√©taill√©e pour l'annale **ESIR SYS1 CC2 2022‚Äì2023**, structur√©e selon vos instructions :

---

# 04_SYS_CC2_2022_2023_sujet üìÑ
**üìÑ PDF original** : [04_SYS_CC2_2022_2023_sujet.pdf](./annales/04_SYS_CC2_2022_2023_sujet.pdf)

---

### üéØ **ANALYSE GLOBALE**
!!! note "üìä Statistiques"
    - **Th√®mes abord√©s** :
      - Assembleur x86-64 (30%)
      - Gestion m√©moire (tas/pile, allocation) (25%)
      - Compilation et linkage (20%)
      - Architecture processeur (pipelining, caches) (15%)
      - Fichiers et entr√©es/sorties (10%)
    - **Types de questions** :
      - QCM (20 questions, 10 points)
      - Questions ouvertes (2 questions, 10 points) avec analyse de code assembleur/C
    - **Pi√®ges fr√©quents** :
      - Confusion entre registres (ex: `ecx` vs `rcx`)
      - Modes d'ouverture de fichiers en C (`"w"` vs `"a"`)
      - Diff√©rence entre binaire et texte en √©criture fichier

---

### üß© **QUESTIONS D√âTAILL√âES**

!!! example "üî¢ Question 1 : Sortie d'un programme assembleur NASM"
    **√ânonc√© original** :
    > Quel est le r√©sultat du programme NASM suivant qui modifie une cha√Æne ASCII ?
    ```nasm
    SECTION .data
    message: db 'HELLO WORLD!',10
    len: equ $-message
    SECTION .text
    _start:
    mov rsi, 0
    loop:
    cmp BYTE [message+rsi], '!'
    je end
    add BYTE [message+rsi], 'a'-'A'  ; Conversion en minuscules
    inc rsi
    jmp loop
    end:
    mov rax, 1
    mov rdi, 1
    mov rsi, message
    mov rdx, len
    syscall
    ```

    !!! success "üü¢ Solution"
        1. **M√©thode** :
           - Le programme parcourt la cha√Æne jusqu'au caract√®re `'!'` et convertit chaque lettre en minuscule en ajoutant `32` (diff√©rence ASCII entre `'A'` et `'a'`).
           - Le caract√®re `'!'` n'est pas modifi√© (condition `je end`).
        2. **√âtapes** :
           - `'H' ‚Üí 'h'`, `'E' ‚Üí 'e'`, ..., `'D' ‚Üí 'd'`.
           - Le `'!'` reste inchang√©.
           - La sortie inclut un retour √† la ligne (`10` en ASCII).
        3. **R√©sultat** : `$oxed{	ext{hello world!}}$` (avec retour √† la ligne).

    !!! tip "üí° Liens utiles"
        - **Cours associ√©** : "Assembleur x86-64" (Chapitre 2, manipulation de cha√Ænes)
        - **TD similaire** : TD2, Exercice 3 (conversion ASCII)
        - **Points cl√©s** :
          - `add BYTE [message+rsi], 'a'-'A'` : Op√©ration sur les valeurs ASCII.
          - `syscall` avec `rax=1` : Appel syst√®me `write`.

    !!! warning "‚ö†Ô∏è Pi√®ges"
        - **Erreur classique** : Oublier que `'!'` n'est pas modifi√© (la boucle s'arr√™te avant).
        - **Conseil** : V√©rifier les bornes des boucles en assembleur.

---

!!! example "üî¢ Question 2 : Lib√©ration m√©moire en C"
    **√ânonc√© original** :
    > Quelle fonction C permet de lib√©rer de la m√©moire allou√©e sur le tas ?

    !!! success "üü¢ Solution"
        1. **R√©ponse** : `$oxed{	ext{free}}$`.
        2. **Explication** :
           - `malloc`, `calloc`, `realloc` allouent sur le tas.
           - `free` lib√®re cette m√©moire.

    !!! tip "üí° Liens"
        - **Cours** : "Gestion m√©moire en C" (Chapitre 3)
        - **TD** : TD4, Exercice 1 (allocation dynamique)

---

!!! example "üî¢ Question 3 : Taille du registre `ecx` en x86-64"
    **√ânonc√© original** :
    > Sur combien de bits fonctionne le registre `ecx` en x86-64 ?

    !!! success "üü¢ Solution"
        1. **R√©ponse** : `$oxed{32}$` bits.
        2. **D√©tails** :
           - En x86-64, `ecx` est la version 32 bits du registre `rcx` (64 bits).
           - Les registres 32 bits sont les plus utilis√©s pour la compatibilit√©.

    !!! warning "‚ö†Ô∏è Pi√®ges"
        - Confusion avec `rcx` (64 bits) ou `cx` (16 bits).

---

!!! example "üî¢ Question 21 : Passage de param√®tre en C (appel r√©cursif)"
    **√ânonc√© original** :
    > Quel type de passage de param√®tre le compilateur a-t-il utilis√© pour la fonction `foo` ?

    !!! success "üü¢ Solution"
        1. **M√©thode** : Passage par **registre** (convention x86-64).
        2. **Preuves** :
           - `mov edi, 0x5` : Le param√®tre `5` est pass√© dans `edi` (registre pour le 1er argument en x86-64).
           - `call 1135 <foo>` : Appel de la fonction.
        3. **R√©sultat** : `$oxed{	ext{Passage par registre (edi)}}$`.

    !!! tip "üí° Liens"
        - **Cours** : "Appels de fonctions en assembleur" (Chapitre 5)
        - **TD** : TD5, Exercice 2 (r√©cursivit√© et pile)

---

!!! example "üî¢ Question 22 : Analyse du prologue et de la pile en assembleur"
    **√ânonc√© original** :
    > (a) Comment s‚Äôappellent les trois premi√®res instructions du code d√©compil√© de `foo` ? √Ä quoi servent-elles ?

    !!! success "üü¢ Solution"
        1. **Instructions** :
           ```nasm
           push rbp      ; Sauvegarde du pointeur de base de la pile
           mov rbp, rsp  ; Initialisation du nouveau pointeur de base
           sub rsp, 0x10 ; Allocation de 16 octets sur la pile
           ```
        2. **Nom** : **Prologue de fonction**.
        3. **R√¥le** :
           - `push rbp` : Sauvegarde l'ancien `rbp` pour le restaurer √† la fin.
           - `mov rbp, rsp` : Cr√©e un nouveau cadre de pile.
           - `sub rsp, 0x10` : R√©serve de l'espace pour les variables locales.

    !!! tip "üí° Liens"
        - **Cours** : "Gestion de la pile en assembleur" (Chapitre 4)
        - **TD** : TD3, Exercice 4 (analyse de prologue/√©pilogue)

---

### üìä **SYNTH√àSE POUR LA R√âVISION**
!!! note "üìå √Ä retenir"
    - **Top 3 concepts** :
      1. **Assembleur x86-64** : Registres, appels syst√®me (`syscall`), manipulation de cha√Ænes.
      2. **Gestion m√©moire** : Tas vs pile, allocation dynamique (`malloc`/`free`).
      3. **Compilation/linkage** : Biblioth√®ques partag√©es, symboles non d√©finis.
    - **1 question type √† ma√Ætriser** :
      - Analyse d'un code assembleur (prologue, passage de param√®tres, r√©cursivit√©).
    - **1 m√©thode r√©utilisable** :
      - **D√©cortiquer un code assembleur** :
        1. Identifier le prologue/√©pilogue.
        2. Rep√©rer les registres utilis√©s pour les arguments.
        3. Suivre les appels de fonctions et les sauts conditionnels.

---

### üîç **REMARQUES G√âN√âRALES**
- **Points faibles fr√©quents** :
  - Confusion entre `fprintf` et `fopen` (Question 6).
  - M√©moire des tailles de registres (Question 3).
  - Diff√©rence entre binaire et texte en √©criture fichier (Question 9).
- **Strat√©gie de r√©vision** :
  - **Pratique** : Recompiler et d√©compiler des programmes C simples avec `gcc -S` et `objdump`.
  - **M√©morisation** : Tableau des registres x86-64 et leurs tailles.
  - **Fiches** : Cr√©er une fiche "Appels syst√®me Unix" (ex: `write`, `exit`).