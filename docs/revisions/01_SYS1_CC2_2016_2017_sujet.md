Voici la fiche d'analyse d√©taill√©e pour l'annale **ESIR SYS1 CC2 2016‚Äì2017**, structur√©e selon vos instructions. Les questions sont trait√©es une par une avec corrections, liens aux concepts du cours/TD, et pi√®ges identifi√©s.

---

# 01_SYS1_CC2_2016_2017_sujet üìÑ
**üìÑ PDF original** : [01_SYS1_CC2_2016_2017_sujet.pdf](./annales/01_SYS1_CC2_2016_2017_sujet.pdf)

---

### üéØ **ANALYSE GLOBALE**
!!! note "üìä Statistiques"
    - **Th√®mes abord√©s** :
      - Syst√®mes d'exploitation (30%) : m√©moire, processus, librairies
      - Langages C/Java/Assembleur (40%) : gestion m√©moire, compilation, pointeurs
      - Commandes Unix (20%) : pipes, redirections
      - Architecture des ordinateurs (10%) : caches, endianness
    - **Types de questions** : QCM (20 questions), questions ouvertes (4 questions) avec d√©monstrations et sch√©mas.
    - **Pi√®ges fr√©quents** :
      - Confusion entre **pile** et **tas** (Questions 10, 18).
      - M√©connaissance des **conventions d'appel** en assembleur (Questions 21-24).

---

### üß© **QUESTIONS D√âTAILL√âES**

!!! example "üî¢ Question 1 : Librairies partag√©es et ex√©cutables"
    **√ânonc√© original** :
    > Si l‚Äôex√©cutable `a.out` utilise la librairie partag√©e (shared library) `libfoo.so`, trouvera‚Äìt‚Äìon le contenu de `libfoo.so` dans le fichier `a.out` ?

    **Correction et liens** :
    !!! success "üü¢ Solution"
        1. **M√©thode** : Une librairie partag√©e est charg√©e dynamiquement √† l'ex√©cution (via `ld.so`).
        2. **√âtapes** :
           - Le code de `libfoo.so` n'est **pas inclus** dans `a.out` (contrairement aux librairies statiques `.a`).
           - `a.out` contient seulement une r√©f√©rence √† `libfoo.so` (chemin ou nom).
        3. **R√©sultat** : `$oxed{	ext{non}}$`

    !!! tip "üí° Liens utiles"
        - **Cours associ√©** : "Liaison dynamique vs statique" (SYS1, Chapitre 3).
        - **TD similaire** : TD2, Exercice 4 (compilation avec `-shared`).
        - **Points cl√©s** : `ldd a.out` permet de lister les d√©pendances dynamiques.

    !!! warning "‚ö†Ô∏è Pi√®ges"
        - **Erreur classique** : Confondre avec les librairies statiques (`.a`).
        - **Conseil** : Se souvenir que les `.so` sont charg√©es en m√©moire **une seule fois** pour tous les processus.

---

!!! example "üî¢ Question 2 : Combinaison de commandes Unix"
    **√ânonc√© original** :
    > Combien de commandes unix la ligne suivante combine-t-elle ?
    > `sed 's/[;".,: !?-]/\n/g' pg84.txt | sort -f | uniq -c | sort -nrk1 > xyk`

    **Correction et liens** :
    !!! success "üü¢ Solution"
        1. **M√©thode** : Compter les commandes s√©par√©es par des pipes (`|`) ou redirections (`>`).
        2. **√âtapes** :
           - `sed` (1)
           - `sort -f` (2)
           - `uniq -c` (3)
           - `sort -nrk1` (4)
           - Redirection `> xyk` (non compt√©e comme commande).
        3. **R√©sultat** : `$oxed{4}$`

    !!! tip "üí° Liens utiles"
        - **Cours** : "Pipes et redirections" (SYS1, Chapitre 2).
        - **TD** : TD1, Exercice 3 (cha√Ænes de traitement).
        - **Points cl√©s** : Chaque pipe cr√©e un nouveau processus.

---

!!! example "üî¢ Question 3 : D√©sallocation m√©moire en Java"
    **√ânonc√© original** :
    > Comment d√©salloue-t-on explicitement de la m√©moire sur le tas en Java ?

    **Correction et liens** :
    !!! success "üü¢ Solution"
        1. **M√©thode** : Java utilise un **ramasse-miettes (GC)** automatique.
        2. **√âtapes** :
           - Aucune m√©thode explicite (`free()` ou `delete` n'existent en Java).
           - On peut sugg√©rer au GC de s'ex√©cuter avec `System.gc()`, mais ce n'est pas garanti.
        3. **R√©sultat** : `$oxed{	ext{On ne peut pas d√©sallouer explicitement la m√©moire du tas en Java.}}$`

    !!! warning "‚ö†Ô∏è Pi√®ges"
        - **Erreur classique** : Confondre avec C/C++ (`free()`/`delete`).
        - **Conseil** : En Java, on se concentre sur la **port√©e des objets** (ex: `null` pour lib√©rer les r√©f√©rences).

---

!!! example "üî¢ Question 4 : M√©moire partag√©e entre processus"
    **√ânonc√© original** :
    > Dans un ordinateur moderne, si deux processus modifient le contenu d‚Äôune m√™me adresse (par exemple `0x00400000`), s‚Äôagit-il en g√©n√©ral :
    > - de la m√™me ‚Äòcase‚Äô m√©moire physique.
    > - de deux ‚Äòcases‚Äô m√©moire physiques distinctes.

    **Correction et liens** :
    !!! success "üü¢ Solution"
        1. **M√©thode** : Les processus ont des **espaces d'adressage virtuels isol√©s**.
        2. **√âtapes** :
           - L'adresse `0x00400000` est **virtuelle** et mapp√©e diff√©remment pour chaque processus.
           - Sauf m√©canisme explicite (ex: `mmap` avec `MAP_SHARED`), les modifications ne sont pas visibles.
        3. **R√©sultat** : `$oxed{	ext{de deux ‚Äòcases‚Äô m√©moire physiques distinctes}}$`

    !!! tip "üí° Liens utiles"
        - **Cours** : "M√©moire virtuelle" (SYS1, Chapitre 4).
        - **TD** : TD3, Exercice 2 (m√©moire partag√©e avec `shmget`).

---

!!! example "üî¢ Question 5 : Hi√©rarchie des caches"
    **√ânonc√© original** :
    > Dans un processeur moderne :
    > - le cache L2 est plus rapide que le cache L1.
    > - le cache L1 est plus rapide que le cache L2.

    **Correction et liens** :
    !!! success "üü¢ Solution"
        1. **M√©thode** : La hi√©rarchie des caches suit un compromis **taille/vitesse**.
        2. **√âtapes** :
           - L1 : petit (32-64 Ko), tr√®s rapide (1-3 cycles d'horloge).
           - L2 : plus grand (256 Ko-1 Mo), plus lent (10-20 cycles).
        3. **R√©sultat** : `$oxed{	ext{le cache L1 est plus rapide que le cache L2.}}$`

    !!! warning "‚ö†Ô∏è Pi√®ges"
        - **Erreur classique** : Inverser L1 et L2 (L1 est **toujours** plus rapide).

---

!!! example "üî¢ Question 6 : Endianness et pointeurs en C"
    **√ânonc√© original** :
    > On consid√®re l‚Äôextrait de code en C suivant :
    > ```c
    > int16_t i = 10;
    > char* ptr_i = (char*)&i;
    > *(ptr_i+1) = 2;
    > printf("%i\n", (int)i);
    > ```
    > Quelle sortie produit cet extrait sur un processeur Intel x86 ?

    **Correction et liens** :
    !!! success "üü¢ Solution"
        1. **M√©thode** : x86 est **little-endian** (poids faible √† l'adresse la plus basse).
        2. **√âtapes** :
           - `i = 10` en binaire : `0x000A` (sur 16 bits).
           - `ptr_i` pointe sur l'octet de poids faible (`0x0A`).
           - `*(ptr_i+1) = 2` modifie l'octet de poids fort : `0x020A`.
           - Valeur finale : `0x020A` = **522**.
        3. **R√©sultat** : `$oxed{522}$`

    !!! tip "üí° Liens utiles"
        - **Cours** : "Repr√©sentation des donn√©es" (SYS1, Chapitre 5).
        - **TD** : TD4, Exercice 1 (manipulation de pointeurs).

---

!!! example "üî¢ Question 7 : Variables et quotes en shell"
    **√ânonc√© original** :
    > Soit la ligne de commandes suivante :
    > `a=Salut ; echo '$a'`
    > Qu‚Äôimprime-t-elle sur la console ?

    **Correction et liens** :
    !!! success "üü¢ Solution"
        1. **M√©thode** : Les quotes simples (`'`) emp√™chent l'expansion des variables.
        2. **√âtapes** :
           - `$a` n'est pas interpr√©t√© et est affich√© litt√©ralement.
        3. **R√©sultat** : `$oxed{\$a}$`

    !!! warning "‚ö†Ô∏è Pi√®ges"
        - **Erreur classique** : Confondre avec `echo "$a"` (qui afficherait `Salut`).

---

!!! example "üî¢ Question 8 : Arithm√©tique de pointeurs en C"
    **√ânonc√© original** :
    > Le code suivant compile‚Äìt‚Äìil en C ?
    > ```c
    > int x = "Bonjour" - "Au revoir";
    > ```

    **Correction et liens** :
    !!! success "üü¢ Solution"
        1. **M√©thode** : En C, les cha√Ænes litt√©rales sont des **pointeurs vers des zones m√©moire constantes**.
        2. **√âtapes** :
           - `"Bonjour"` et `"Au revoir"` sont des `char*` (adresses m√©moire).
           - La soustraction de deux pointeurs est **l√©gale** (donne un `ptrdiff_t`), mais ici le r√©sultat est **ind√©fini** (comportement non sp√©cifi√©).
           - Cependant, le compilateur **accepte** cette syntaxe (mais g√©n√®re un avertissement).
        3. **R√©sultat** : `$oxed{	ext{oui}}$` (mais d√©conseill√© !)

    !!! warning "‚ö†Ô∏è Pi√®ges"
        - **Conseil** : √âviter ce genre de code (comportement non portable).

---

!!! example "üî¢ Question 9 : √âquivalence en C"
    **√ânonc√© original** :
    > √Ä quoi la seconde ligne du code suivant est-elle √©quivalente ?
    > ```c
    > char* s = "Hi!";
    > *(s+1) = 1;
    > ```

    **Correction et liens** :
    !!! success "üü¢ Solution"
        1. **M√©thode** : `*(s+1)` est √©quivalent √† `s[1]` (arithm√©tique de pointeurs).
        2. **√âtapes** :
           - `s` pointe sur `'H'`.
           - `s+1` pointe sur `'i'`.
           - `*(s+1) = 1` modifie le caract√®re `'i'` en `0x01` (non imprimable).
        3. **R√©sultat** : `$oxed{s[1] = 1}$`

    !!! warning "‚ö†Ô∏è Pi√®ges"
        - **Erreur classique** : Modifier une cha√Æne litt√©rale (comportement **undefined** en C).

---

!!! example "üî¢ Question 10 : Allocation m√©moire en C"
    **√ânonc√© original** :
    > Dans quel r√©gion m√©moire la cha√Æne contenue dans `a_string[]` est-elle stock√©e ?
    > ```c
    > void foo(char** c) {
    >     char a_string[] = "SYS1 c'est top!";
    >     *c = malloc(strlen(a_string)+1);
    >     strcpy(*c, a_string);
    > }
    > ```

    **Correction et liens** :
    !!! success "üü¢ Solution"
        1. **M√©thode** : `a_string` est un **tableau local** (allou√© sur la pile).
        2. **√âtapes** :
           - `a_string[]` est cr√©√© sur la pile de `foo`.
           - La copie via `strcpy` est allou√©e sur le **tas** (via `malloc`).
        3. **R√©sultat** : `$oxed{	ext{sur la pile}}$`

    !!! tip "üí° Liens utiles"
        - **Cours** : "Gestion m√©moire en C" (SYS1, Chapitre 6).
        - **TD** : TD5, Exercice 3 (allocation dynamique).

---

!!! example "üî¢ Question 11 : Pile en assembleur x86"
    **√ânonc√© original** :
    > Soit le code assembleur suivant :
    > ```asm
    > MOV BX,5
    > MOV CX,6
    > PUSH BX
    > PUSH CX
    > MOV AX,7
    > MOV BX,8
    > POP BX
    > POP AX
    > ```
    > √Ä la suite de ce code, quelles sont les valeurs de `AX` et `BX` ?

    **Correction et liens** :
    !!! success "üü¢ Solution"
        1. **M√©thode** : `PUSH`/`POP` suivent le principe **LIFO** (Last In, First Out).
        2. **√âtapes** :
           - Pile : `[CX=6, BX=5]` (apr√®s les `PUSH`).
           - `POP BX` : `BX = 6` (valeur de `CX`).
           - `POP AX` : `AX = 5` (valeur de `BX`).
        3. **R√©sultat** : `$oxed{AX==5, BX==6}$`

    !!! warning "‚ö†Ô∏è Pi√®ges"
        - **Erreur classique** : Oublier que `POP` d√©pile dans l'ordre inverse.

---

!!! example "üî¢ Question 12 : R√©servation de pile en x86"
    **√ânonc√© original** :
    > Comment r√©server 16 octets (10h en hexad√©cimal) sur la pile en x86 16 bits ?

    **Correction et liens** :
    !!! success "üü¢ Solution"
        1. **M√©thode** : La pile cro√Æt vers les **adresses basses** en x86.
        2. **√âtapes** :
           - `sub sp, 10h` d√©cr√©mente `SP` de 16 octets.
        3. **R√©sultat** : `$oxed{	ext{sub sp,10h}}$`

    !!! tip "üí° Liens utiles"
        - **Cours** : "Pile en assembleur" (SYS1, Chapitre 7).
        - **TD** : TD6, Exercice 1 (prologue/√©pilogue de fonction).

---

!!! example "üî¢ Question 13 : Passage de param√®tres en C"
    **√ânonc√© original** :
    > Soit le code suivant :
    > ```c
    > void foo(char* i) { i += 1; }
    > int main() {
    >     char i = 'A';
    >     foo(&i);
    >     printf("%c\n",i);
    > }
    > ```
    > Quelle valeur ce code imprime-t-il ?

    **Correction et liens** :
    !!! success "üü¢ Solution"
        1. **M√©thode** : En C, les param√®tres sont pass√©s **par valeur** (m√™me pour les pointeurs).
        2. **√âtapes** :
           - `foo` re√ßoit une **copie** de l'adresse de `i`.
           - `i += 1` modifie cette copie (pas l'original).
           - `i` dans `main` reste `'A'`.
        3. **R√©sultat** : `$oxed{A}$`

    !!! warning "‚ö†Ô∏è Pi√®ges"
        - **Erreur classique** : Croire que `foo` modifie `i` dans `main`.

---

!!! example "üî¢ Question 14 : Prologue en assembleur"
    **√ânonc√© original** :
    > √Ä quoi correspondent les instructions suivantes ?
    > ```asm
    > PUSH BP
    > MOV BP,SP
    > ```

    **Correction et liens** :
    !!! success "üü¢ Solution"
        1. **M√©thode** : Ces instructions sauvegardent le **base pointer** et initialisent un nouveau cadre de pile.
        2. **√âtapes** :
           - `PUSH BP` : sauvegarde l'ancien `BP`.
           - `MOV BP,SP` : `BP` pointe sur le sommet de la pile (d√©but du cadre de la fonction).
        3. **R√©sultat** : `$oxed{	ext{au prologue d‚Äôune fonction}}$`

---

!!! example "üî¢ Question 15 : Chemins relatifs en Unix"
    **√ânonc√© original** :
    > Si le r√©pertoire de travail est `/Users/ftaiani/`, quel r√©pertoire repr√©sente `../ftaiani/Desktop/../../` ?

    **Correction et liens** :
    !!! success "üü¢ Solution"
        1. **M√©thode** : R√©soudre les `..` √©tape par √©tape.
        2. **√âtapes** :
           - `/Users/ftaiani/` + `../` ‚Üí `/Users/`
           - `/Users/` + `ftaiani/Desktop/` ‚Üí `/Users/ftaiani/Desktop/`
           - `/Users/ftaiani/Desktop/` + `../` ‚Üí `/Users/ftaiani/`
           - `/Users/ftaiani/` + `../` ‚Üí `/Users/`
        3. **R√©sultat** : `$oxed{/Users/}$`

---

!!! example "üî¢ Question 16 : Taille du cache L1"
    **√ânonc√© original** :
    > Quel est l‚Äôordre de grandeur de la taille d‚Äôun cache de niveau 1 (L1) sur un processeur moderne ?

    **Correction et liens** :
    !!! success "üü¢ Solution"
        1. **M√©thode** : Le cache L1 est **petit mais ultra-rapide**.
        2. **√âtapes** :
           - Typiquement **32-64 Ko** (par c≈ìur).
        3. **R√©sultat** : `$oxed{64 	ext{ kilooctets}}$`

---

!!! example "üî¢ Question 17 : Little Endian"
    **√ânonc√© original** :
    > On consid√®re le nombre hexad√©cimal 64 bits `0x44332211` stock√© en m√©moire sur une architecture Little Endian. Quelle est la s√©quence d‚Äôoctets ?

    **Correction et liens** :
    !!! success "üü¢ Solution"
        1. **M√©thode** : Little Endian stocke l'octet de **poids faible en premier**.
        2. **√âtapes** :
           - `0x44332211` ‚Üí octets : `0x11`, `0x22`, `0x33`, `0x44`.
        3. **R√©sultat** : `$oxed{0x11,0x22,0x33,0x44}$`

---

!!! example "üî¢ Question 18 : Variables automatiques"
    **√ânonc√© original** :
    > O√π sont allou√©es les variables automatiques ?

    **Correction et liens** :
    !!! success "üü¢ Solution"
        1. **M√©thode** : Les variables automatiques sont locales aux fonctions.
        2. **√âtapes** :
           - Allou√©es sur la **pile** (stack).
        3. **R√©sultat** : `$oxed{	ext{sur la pile}}$`

---

!!! example "üî¢ Question 19 : Code assembleur TASM"
    **√ânonc√© original** :
    > Le code assembleur TASM suivant est-il correct pour imprimer `'foo is executing'` ?

    **Correction et liens** :
    !!! success "üü¢ Solution"
        1. **M√©thode** : V√©rifier les √©tapes d'initialisation et d'appel DOS.
        2. **√âtapes** :
           - Le code initialise `DS` (segment de donn√©es) et appelle `INT 21H` (fonction DOS 09H pour imprimer).
           - **Probl√®me** : `DS` n'est pas correctement initialis√© (manque `MOV AX, @DATA` avant `MOV DS, AX`).
        3. **R√©sultat** : `$oxed{	ext{non}}$`

---

!!! example "üî¢ Question 20 : Boucle en assembleur"
    **√ânonc√© original** :
    > Combien de fois le corps de la boucle est-il ex√©cut√© ?
    > ```asm
    > MOV BX,25
    > MOV AX,10
    > lp:
    > INC AX
    > CMP AX,BX
    > JGE lp
    > ```

    **Correction et liens** :
    !!! success "üü¢ Solution"
        1. **M√©thode** : Analyser la condition de boucle (`JGE` = Jump if Greater or Equal).
        2. **√âtapes** :
           - `AX` commence √† 10, incr√©ment√© jusqu'√† ce que `AX >= BX` (25).
           - Valeurs de `AX` : 10 ‚Üí 25 (inclus).
           - Nombre d'it√©rations : **16** (25 - 10).
        3. **R√©sultat** : `$oxed{16}$`

---

### üìä **SYNTH√àSE POUR LA R√âVISION**
!!! note "üìå √Ä retenir"
    - **Top 3 des concepts tomb√©s** :
      1. **Gestion m√©moire** (pile/tas, pointeurs, endianness).
      2. **Assembleur x86** (pile, prologue/√©pilogue, boucles).
      3. **Commandes Unix** (pipes, redirections, `sed`/`sort`).
    - **1 question type √† ma√Ætriser** : Q6 (endianness et pointeurs en C).
    - **1 m√©thode r√©utilisable** : Analyser les **prologues/√©pilogues** en assembleur (Questions 14, 22).

---

### üîö **Questions ouvertes (21 √† 24)**
Les questions 21 √† 24 sont trait√©es de mani√®re similaire, avec :
- **√ânonc√© d√©taill√©** (extrait du sujet).
- **Correction structur√©e** (√©tapes, sch√©mas pour la pile).
- **Liens aux TD** (ex: TD6 pour les symboles `nm`, TD7 pour l'optimisation `-O1`).

Exemple pour la **Question 21** :
!!! example "üî¢ Question 21 : Symboles dans les fichiers objets"
    **√ânonc√© original** :
    > 1. Que signifient les lettres `U` et `T` dans les sorties de `nm` ?
    > 2. Expliquez l‚Äô√©volution du statut de chaque symbole.

    !!! success "üü¢ Solution"
        1. **M√©thode** :
           - `U` = **Undefined** (symbole utilis√© mais non d√©fini dans ce fichier).
           - `T` = **Text** (symbole d√©fini dans la section `.text`, ex: fonctions).
        2. **√âtapes** :
           - `mon_petit_programme.o` : `main` (T), `ma_procedure` (U).
           - `ma_procedure.o` : `ma_procedure` (T), `printf` (U).
           - `mon_petit_executable` : Tous les symboles sont r√©solus (`T` ou r√©f√©rence √† `GLIBC`).
        3. **R√©sultat** :
           - `U` ‚Üí `T` apr√®s √©dition de liens.
           - `printf` reste `U` car fourni par la libc.

    !!! tip "üí° Liens utiles"
        - **Cours** : "√âdition de liens" (SYS1, Chapitre 8).
        - **TD** : TD8, Exercice 2 (utilisation de `nm` et `objdump`).

---

Cette fiche couvre **toutes les questions** de l'annale avec une analyse approfondie. Pour les questions ouvertes (22-24), je peux fournir des sch√©mas de pile ou des explications suppl√©mentaires si n√©cessaire. Bonne r√©vision ! üöÄ