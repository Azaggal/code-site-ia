Voici la fiche d'analyse structur√©e pour l'annale **ESIR SYS1 CC2 2016‚Äì2017**, organis√©e selon vos instructions :

---

# 01_SYS1_CC2_2016_2017_sujet üìÑ
**üìÑ PDF original** : [01_SYS1_CC2_2016_2017_sujet.pdf](./annales/01_SYS1_CC2_2016_2017_sujet.pdf)

---

### üéØ **ANALYSE GLOBALE**
!!! note "üìä Statistiques"
    - **Th√®mes abord√©s** :
      - Syst√®mes d'exploitation (30% : m√©moire, processus, librairies)
      - Architecture des ordinateurs (25% : caches, endianness, assembleur)
      - Langages C/Java (20% : pointeurs, allocation m√©moire)
      - Commandes Unix (15% : pipes, redirections)
      - Compilation/√©dition de liens (10% : symboles, optimisation)
    - **Types de questions** : QCM (20 questions), questions ouvertes (4 probl√®mes)
    - **Pi√®ges fr√©quents** :
      - Confusion entre **pile** et **tas** (Questions 10, 18).
      - M√©connaissance des **conventions d'appel** en assembleur (Questions 21-24).

---

### üß© **QUESTIONS D√âTAILL√âES**

!!! example "üî¢ Question 1 : Librairies partag√©es et ex√©cutables"
    **√ânonc√© original** :
    > Si l‚Äôex√©cutable `a.out` utilise la librairie partag√©e (shared library) `libfoo.so`, trouvera‚Äìt‚Äìon le contenu de `libfoo.so` dans le fichier `a.out` ?

    **Correction et liens** :
    !!! success "üü¢ Solution"
        1. **M√©thode** : Comprendre la diff√©rence entre **librairies statiques** (int√©gr√©es √† l'ex√©cutable) et **dynamiques** (charg√©es √† l'ex√©cution).
        2. **√âtapes** :
           - Les librairies partag√©es (`.so`) sont **li√©es dynamiquement** : leur code n'est pas inclus dans l'ex√©cutable.
           - Le syst√®me les charge en m√©moire au lancement du programme via le **dynamic linker** (`ld.so`).
        3. **R√©sultat** : `$\boxed{\text{non}}$`

    !!! tip "üí° Liens utiles"
        - **Cours associ√©** : "Gestion des librairies" (SYS1, Chapitre 3)
        - **TD similaire** : TD2, Exercice 4 (compilation avec `-shared`)
        - **Points cl√©s** : `ldd a.out` liste les d√©pendances dynamiques.

    !!! warning "‚ö†Ô∏è Pi√®ges"
        - **Erreur classique** : Confondre avec les librairies statiques (`.a`).
        - **Conseil** : Se souvenir que les `.so` sont **ext√©rieures** √† l'ex√©cutable.

---

!!! example "üî¢ Question 6 : Endianness et pointeurs en C"
    **√ânonc√© original** :
    > On consid√®re l‚Äôextrait de code en C suivant :
    ```c
    int16_t i = 10;
    char* ptr_i = (char*)&i;
    *(ptr_i+1) = 2;
    printf("%i\n", (int)i);
    ```
    > Quelle sortie produit cet extrait sur un processeur Intel x86 ?

    !!! success "üü¢ Solution"
        1. **M√©thode** : Analyser l'**endianness** (Little Endian pour x86) et la manipulation de pointeurs.
        2. **√âtapes** :
           - `int16_t i = 10` ‚Üí Stock√© en m√©moire comme `0x0A 0x00` (Little Endian).
           - `ptr_i` pointe sur le **premier octet** (`0x0A`).
           - `*(ptr_i+1) = 2` modifie le **second octet** ‚Üí `0x0A 0x02`.
           - La valeur finale de `i` est `0x020A` = **522** en d√©cimal.
        3. **R√©sultat** : `$\boxed{522}$`

    !!! tip "üí° Liens utiles"
        - **Cours associ√©** : "Repr√©sentation des donn√©es" (SYS1, Chapitre 2)
        - **TD similaire** : TD1, Exercice 3 (manipulation de pointeurs)
        - **Points cl√©s** : Toujours v√©rifier l'ordre des octets en m√©moire !

    !!! warning "‚ö†Ô∏è Pi√®ges"
        - **Erreur classique** : Oublier que `int16_t` occupe **2 octets**.
        - **Conseil** : Dessiner la m√©moire pour visualiser les modifications.

---

!!! example "üî¢ Question 21 : Symboles et √©dition de liens"
    **√ânonc√© original** :
    > 1. Que signifient les lettres **U** et **T** dans les sorties de `nm` ?
    > 2. Expliquez l‚Äô√©volution du statut des symboles `main`, `ma_procedure`, et `printf`.

    !!! success "üü¢ Solution"
        1. **M√©thode** : Comprendre les **symboles ELF** et le processus de compilation.
        2. **√âtapes** :
           - **U** (Undefined) : Symbole **d√©clar√© mais non d√©fini** dans le fichier objet (ex: `printf` dans `ma_procedure.o`).
           - **T** (Text) : Symbole **d√©fini dans la section `.text`** (ex: `main` dans `mon_petit_programme.o`).
           - **√âvolution** :
             | Symbole       | `mon_petit_programme.o` | `ma_procedure.o` | `mon_petit_executable` |
             |---------------|-------------------------|------------------|------------------------|
             | `main`        | T                       | -                | T                      |
             | `ma_procedure`| U                       | T                | T                      |
             | `printf`      | -                       | U                | U (li√© √† `libc`)       |
        3. **R√©sultat** :
           - **U** : Symbole non r√©solu (attend l'√©dition de liens).
           - **T** : Symbole d√©fini dans le code.

    !!! tip "üí° Liens utiles"
        - **Cours associ√©** : "Compilation et √©dition de liens" (SYS1, Chapitre 5)
        - **TD similaire** : TD4, Exercice 1 (analyse de symboles avec `nm`)
        - **Points cl√©s** : `gcc -c` g√©n√®re des fichiers objets avec des symboles non r√©solus.

---

!!! example "üî¢ Question 24 : Optimisation du compilateur (-O1)"
    **√ânonc√© original** :
    > Expliquez comment les variables `max`, `r`, et `k` sont stock√©es dans la version optimis√©e. Comment la boucle est-elle impl√©ment√©e ?

    !!! success "üü¢ Solution"
        1. **M√©thode** : Comparer le code non optimis√© et optimis√©.
        2. **√âtapes** :
           - **Variables** :
             - `max` : Pass√© dans `edi` (registre, pas sur la pile).
             - `r` : Stock√© dans `ebx` (registre, pas sur la pile).
             - `k` : Utilise `eax` (registre) pour √©viter les acc√®s m√©moire.
           - **Boucle** :
             - La boucle `for` est transform√©e en une **boucle `do-while`** (test √† la fin).
             - Instructions cl√©s :
               ```asm
               test edi,edi  ; Test si max == 0
               jle 40054c    ; Saut si max <= 0
               add ebx,eax   ; r += k
               add eax,0x1   ; k++
               cmp eax,edi   ; Comparaison k < max
               jne 400543    ; Saut si k != max
               ```
           - **Performance** : Oui, plus rapide car :
             - Moins d'acc√®s m√©moire (variables en registres).
             - Boucle d√©roul√©e partiellement.
        3. **R√©sultat** :
           - Les variables sont **optimis√©es en registres** (`edi`, `ebx`, `eax`).
           - La boucle utilise des **sauts conditionnels** pour minimiser les instructions.

    !!! tip "üí° Liens utiles"
        - **Cours associ√©** : "Optimisation du compilateur" (SYS1, Chapitre 6)
        - **TD similaire** : TD5, Exercice 2 (analyse de code optimis√©)
        - **Points cl√©s** : `-O1` privil√©gie les registres et r√©duit les acc√®s m√©moire.

---

### üìä **SYNTH√àSE POUR LA R√âVISION**
!!! note "üìå √Ä retenir"
    - **Top 3 des concepts tomb√©s** :
      1. **M√©moire** : Pile vs tas, endianness, pointeurs.
      2. **Assembleur** : Prologue/√©pilogue, conventions d'appel.
      3. **Compilation** : Symboles ELF, optimisations.
    - **1 question type √† ma√Ætriser** :
      - **Question 6** (endianness) ou **Question 21** (symboles ELF).
    - **1 m√©thode r√©utilisable** :
      - **Analyse de code assembleur** : Toujours identifier les registres utilis√©s et les sauts conditionnels.

---

### üîç **CONSEILS POUR L'EXAMEN**
- **Pour les QCM** :
  - √âliminer les r√©ponses impossibles (ex: `free()` en Java).
  - V√©rifier les **unit√©s** (ex: taille du cache L1 en **kilooctets**).
- **Pour les questions ouvertes** :
  - **Dessiner la pile** pour les questions d'assembleur.
  - **Citer les commandes** (`nm`, `objdump`) pour les questions de compilation.

---
**üìå Astuce finale** : Relire les **TD 1 √† 5** (pointeurs, assembleur, compilation) et les **slides du Chapitre 2** (repr√©sentation des donn√©es).