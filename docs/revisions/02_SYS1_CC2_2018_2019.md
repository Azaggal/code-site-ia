Voici la fiche d'analyse dÃ©taillÃ©e pour l'annale **02_SYS1_CC2_2018_2019**, structurÃ©e selon vos instructions :

---

# 02_SYS1_CC2_2018_2019 ğŸ“„
**ğŸ“„ PDF original** : [02_SYS1_CC2_2018_2019.pdf](./annales/02_SYS1_CC2_2018_2019.pdf)

---

### ğŸ¯ **ANALYSE GLOBALE**
!!! note "ğŸ“Š Statistiques"
    - **ThÃ¨mes abordÃ©s** :
      - Architecture x86 (30%)
      - Gestion mÃ©moire (25%)
      - Assembleur/TASM (20%)
      - Compilation/Linking (15%)
      - Outils (Make, GCC) (10%)
    - **Types de questions** : QCM (20 questions), questions ouvertes (3 problÃ¨mes)
    - **PiÃ¨ges frÃ©quents** :
      - Confusion entre registres (ex: BX vs BL pour l'octet de poids faible)
      - MÃ©moire (tas vs pile, dÃ©sallocation en Java/C)
      - Optimisations du compilateur (ex: Question 23)

---

### ğŸ§© **QUESTIONS DÃ‰TAILLÃ‰ES**

!!! example "ğŸ”¢ Question 1 : Architecture x86 (bits)"
    **Ã‰noncÃ© original** :
    > Combien de bits utilisent les processeurs x86 typiquement utilisÃ©s de nos jours dans les ordinateurs personnels ?
    > - 8 bits
    > - 16 bits
    > - 32 bits
    > - 64 bits

    !!! success "ğŸŸ¢ Solution"
        1. **MÃ©thode** : Connaissance de l'architecture moderne.
        2. **Ã‰tapes** :
           - Les processeurs x86 actuels (depuis ~2003) sont majoritairement **64 bits** (ex: Intel Core i7, AMD Ryzen).
           - Les options 8/16/32 bits correspondent Ã  des architectures historiques.
        3. **RÃ©sultat** : `$oxed{64 \text{ bits}}$`

    !!! tip "ğŸ’¡ Liens utiles"
        - **Cours associÃ©** : "Architecture des ordinateurs" (Chapitre 2 - Registres et tailles)
        - **TD similaire** : TD1, Exercice 3 (Architecture x86)
        - **Points clÃ©s** : DiffÃ©rencier x86 (32 bits) et x86-64 (64 bits).

    !!! warning "âš ï¸ PiÃ¨ges"
        - **Erreur classique** : Confondre avec les microcontrÃ´leurs 8/16 bits (ex: Arduino).
        - **Conseil** : MÃ©moriser que les PC modernes utilisent x86-64.

---

!!! example "ğŸ”¢ Question 3 : Pointeurs en C"
    **Ã‰noncÃ© original** :
    > Ã€ quoi la seconde ligne du code suivant est-elle Ã©quivalente ?
    > ```c
    > char* s = "Hi!";
    > *(s+1) = 1;
    > ```
    > - `s[1] = 1`
    > - `s = 0`
    > - `s = s + 1`

    !!! success "ğŸŸ¢ Solution"
        1. **MÃ©thode** : ArithmÃ©tique des pointeurs.
        2. **Ã‰tapes** :
           - `s` pointe vers le premier caractÃ¨re (`'H'`).
           - `s+1` pointe vers le deuxiÃ¨me caractÃ¨re (`'i'`).
           - `*(s+1)` est Ã©quivalent Ã  `s[1]` (accÃ¨s au 2Ã¨me caractÃ¨re).
        3. **RÃ©sultat** : `$oxed{s[1] = 1}$`

    !!! tip "ğŸ’¡ Liens utiles"
        - **Cours associÃ©** : "Pointeurs et tableaux" (Chapitre 3)
        - **TD similaire** : TD2, Exercice 4 (Manipulation de pointeurs)
        - **Points clÃ©s** : `*(p+i)` â‰¡ `p[i]`.

    !!! warning "âš ï¸ PiÃ¨ges"
        - **Erreur classique** : Oublier que `s` est un pointeur (pas une chaÃ®ne modifiable ici, car `"Hi!"` est en mÃ©moire constante).
        - **Conseil** : Toujours vÃ©rifier si la chaÃ®ne est modifiable (`char s[] = "Hi!";`).

---

!!! example "ğŸ”¢ Question 4 : Endianness en C"
    **Ã‰noncÃ© original** :
    > On considÃ¨re lâ€™extrait de code en C suivant :
    > ```c
    > int16_t i = 10;
    > char* ptr_i = (char*)&i;
    > ptr_i[0] = 2;
    > printf("%i\n", (int)i);
    > ```
    > Quelle sortie produit cet extrait sur un processeur Intel x86 ?

    !!! success "ğŸŸ¢ Solution"
        1. **MÃ©thode** : Comprendre l'endianness (little-endian pour x86).
        2. **Ã‰tapes** :
           - `int16_t i = 10` â†’ StockÃ© en mÃ©moire comme `0x0A 0x00` (little-endian).
           - `ptr_i[0] = 2` â†’ Modifie l'octet de poids faible (`0x0A` â†’ `0x02`).
           - Nouvelle valeur : `0x02 0x00` â†’ `2` en dÃ©cimal.
        3. **RÃ©sultat** : `$oxed{2}$`

    !!! tip "ğŸ’¡ Liens utiles"
        - **Cours associÃ©** : "ReprÃ©sentation des donnÃ©es" (Chapitre 1 - Endianness)
        - **TD similaire** : TD3, Exercice 2 (Manipulation de mÃ©moire)
        - **Points clÃ©s** : x86 utilise le **little-endian** (poids faible en premier).

    !!! warning "âš ï¸ PiÃ¨ges"
        - **Erreur classique** : Oublier l'endianness et penser que `ptr_i[0]` modifie le poids fort.
        - **Conseil** : Dessiner la mÃ©moire pour visualiser les octets.

---

!!! example "ğŸ”¢ Question 21 : Assembleur et passage de paramÃ¨tres"
    **Ã‰noncÃ© original** :
    > 1. Que va imprimer ce programme ? Proposez un code C Ã©quivalent pour la fonction `foo`.
    > 2. La fonction `foo` utilise un passage de paramÃ¨tres par registre. Quels sont les deux registres utilisÃ©s ? Quels sont leurs rÃ´les ?
    > 3. Transformez le programme pour que `foo` utilise un passage de paramÃ¨tres par la pile.

    !!! success "ğŸŸ¢ Solution"
        **1. Sortie du programme** :
        - `MESSAGE` initial : `'HELLOWORLD','$'`.
        - `foo` ajoute `-1` (soit `0xFF`) Ã  chaque caractÃ¨re jusqu'Ã  `'$'`.
        - RÃ©sultat : `'GDKKNVQKC$'` (car `'H' - 1 = 'G'`, `'E' - 1 = 'D'`, etc.).
        - **Code C Ã©quivalent** :
          ```c
          void foo(char* s, char offset) {
              for (int i = 0; s[i] != '$'; i++) {
                  s[i] += offset;
              }
          }
          ```

        **2. Registres utilisÃ©s** :
        - `BX` : Pointeur vers la chaÃ®ne `MESSAGE`.
        - `AL` : Valeur Ã  ajouter (`-1`).
        - **RÃ´les** : `BX` = paramÃ¨tre d'entrÃ©e, `AL` = paramÃ¨tre d'opÃ©ration.

        **3. Passage par la pile** :
        - **SchÃ©ma de pile** :
          ```
          | ...       |
          | offset    | â† SP+4
          | adresse s | â† SP+2
          | IP        | â† SP (aprÃ¨s CALL)
          ```
        - **Code modifiÃ©** :
          ```asm
          foo:
              PUSH BP
              MOV BP, SP
              PUSH SI
              MOV SI, [BP+4]  ; Adresse de la chaÃ®ne
              MOV AL, [BP+6]  ; Offset
          boucl:
              CMP byte ptr [SI], '$'
              JE fin
              ADD byte ptr [SI], AL
              INC SI
              JMP boucl
          fin:
              POP SI
              POP BP
              RET 4           ; Nettoyer la pile (2 paramÃ¨tres de 2 octets)
          ```
        - **Appel modifiÃ©** :
          ```asm
          PUSH -1            ; Offset
          PUSH offset MESSAGE ; Adresse de la chaÃ®ne
          CALL foo
          ```

    !!! tip "ğŸ’¡ Liens utiles"
        - **Cours associÃ©** : "Assembleur x86" (Chapitre 5 - Passage de paramÃ¨tres)
        - **TD similaire** : TD4, Exercice 3 (Fonctions en assembleur)
        - **Points clÃ©s** :
          - Passage par registre : rapide mais limitÃ©.
          - Passage par pile : plus flexible (nombre illimitÃ© de paramÃ¨tres).

    !!! warning "âš ï¸ PiÃ¨ges"
        - **Erreur classique** : Oublier de nettoyer la pile aprÃ¨s `CALL` (â†’ corruption de la pile).
        - **Conseil** : Toujours dessiner le schÃ©ma de pile avant de coder.

---

!!! example "ğŸ”¢ Question 23 : Optimisation du compilateur"
    **Ã‰noncÃ© original** :
    > Expliquez lâ€™effet de lâ€™optimisation (`-O2`) et pourquoi lâ€™erreur `segmentation fault` a disparu.

    !!! success "ğŸŸ¢ Solution"
        1. **Version non-optimisÃ©e** :
           - Appels rÃ©cursifs infinis â†’ dÃ©bordement de pile (`stack overflow`).
           - Chaque appel ajoute un cadre de pile (`push rbp`, `call`).
        2. **Version optimisÃ©e** :
           - Le compilateur remplace la rÃ©cursion par une **boucle infinie** (`jmp 4004f8`).
           - Plus de crÃ©ation de cadres de pile â†’ pas de dÃ©bordement.
        3. **RÃ©sultat** : Le programme tourne indÃ©finiment sans erreur.

    !!! tip "ğŸ’¡ Liens utiles"
        - **Cours associÃ©** : "Compilation et optimisation" (Chapitre 6)
        - **TD similaire** : TD5, Exercice 1 (Optimisations GCC)
        - **Points clÃ©s** :
          - `-O2` active des optimisations agressives (ex: Ã©limination de la rÃ©cursion terminale).
          - La rÃ©cursion infinie est transformÃ©e en boucle si possible.

    !!! warning "âš ï¸ PiÃ¨ges"
        - **Erreur classique** : Penser que l'optimisation "rÃ©pare" le code (elle change juste le comportement).
        - **Conseil** : Toujours tester les optimisations avec `gdb` ou `objdump`.

---

### ğŸ“Š **SYNTHÃˆSE POUR LA RÃ‰VISION**
!!! note "ğŸ“Œ Ã€ retenir"
    - **Top 3 des concepts tombÃ©s** :
      1. **Endianness** (Questions 4, 5, 9) â†’ Dessiner la mÃ©moire !
      2. **Passage de paramÃ¨tres** (Questions 15, 21) â†’ Registres vs pile.
      3. **Gestion mÃ©moire** (Questions 2, 8, 18) â†’ Tas vs pile, bibliothÃ¨ques dynamiques.
    - **1 question type Ã  maÃ®triser** :
      - **Question 21** (assembleur + passage de paramÃ¨tres) â†’ SchÃ©ma de pile obligatoire.
    - **1 mÃ©thode rÃ©utilisable** :
      - **Analyse de code assembleur** : Toujours identifier les registres utilisÃ©s et leur rÃ´le.

---

### ğŸ” **CONSEILS POUR L'EXAMEN**
- **Pour les QCM** :
  - Ã‰liminer les rÃ©ponses impossibles (ex: `delete` en C â†’ jamais utilisÃ©).
  - VÃ©rifier les unitÃ©s (ex: taille du cache L1 en **kilooctets**, pas mÃ©ga/giga).
- **Pour les questions ouvertes** :
  - **Dessiner** la mÃ©moire/pile avant de coder.
  - **Commenter** chaque ligne d'assembleur (ex: `MOV AX, @DATA` â†’ initialisation du segment de donnÃ©es).
- **Outils utiles** :
  - `gcc -S` pour gÃ©nÃ©rer du code assembleur.
  - `objdump -d` pour dÃ©compiler (comme dans la Question 23).