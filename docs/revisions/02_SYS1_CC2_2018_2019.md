Voici la fiche d'analyse dÃ©taillÃ©e pour l'annale **02_SYS1_CC2_2018_2019**, structurÃ©e selon vos instructions :

---

# 02_SYS1_CC2_2018_2019 ğŸ“„ (Annale 2019)
**ğŸ“„ PDF original** : [02_SYS1_CC2_2018_2019.pdf](./annales/02_SYS1_CC2_2018_2019.pdf)

---

### ğŸ¯ **ANALYSE GLOBALE**
!!! note "ğŸ“Š Statistiques"
    - **ThÃ¨mes abordÃ©s** :
      - Architecture x86 (30%)
      - Gestion mÃ©moire (25%)
      - Assembleur (20%)
      - Compilation et bibliothÃ¨ques (15%)
      - Outils (Make, GCC) (10%)
    - **Types de questions** : QCM (10 questions), questions ouvertes (3 problÃ¨mes), analyse de code assembleur/C.
    - **PiÃ¨ges frÃ©quents** :
      - Confusion entre registres (ex: BX vs BL pour les octets).
      - MÃ©connaissance des conventions d'appel (ABI x86-64).

---

### ğŸ§© **QUESTIONS DÃ‰TAILLÃ‰ES**

!!! example "ğŸ”¢ Question 1 : Taille des processeurs x86"
    **Ã‰noncÃ© original** :
    > Combien de bits utilisent les processeurs x86 typiquement utilisÃ©s de nos jours dans les ordinateurs personnels ?

    **Correction et liens** :
    !!! success "ğŸŸ¢ Solution"
        1. **MÃ©thode** : Connaissance des architectures modernes.
        2. **Ã‰tapes** :
           - Les processeurs x86 actuels (ex: Intel Core, AMD Ryzen) sont majoritairement **64 bits**.
        3. **RÃ©sultat** : `$oxed{64 \text{ bits}}$`

    !!! tip "ğŸ’¡ Liens utiles"
        - **Cours associÃ©** : "Architecture des processeurs" (Chapitre 2, Â§1.2).
        - **TD similaire** : TD1, Exercice 3 (registres et tailles).
        - **Points clÃ©s** : DiffÃ©rencier x86 (32 bits) et x86-64 (64 bits).

    !!! warning "âš ï¸ PiÃ¨ges"
        - **Erreur classique** : Confondre avec les processeurs 32 bits (obsolÃ¨tes pour les PC modernes).

---

!!! example "ğŸ”¢ Question 2 : DÃ©sallocation mÃ©moire en Java"
    **Ã‰noncÃ© original** :
    > Comment dÃ©salloue-t-on explicitement de la mÃ©moire sur le tas en Java ?

    !!! success "ğŸŸ¢ Solution"
        1. **MÃ©thode** : Gestion automatique de la mÃ©moire en Java.
        2. **Ã‰tapes** :
           - Java utilise un **ramasse-miettes (Garbage Collector)** pour dÃ©sallouer automatiquement.
           - Aucune mÃ©thode explicite comme `free()` ou `delete` n'existe.
        3. **RÃ©sultat** : `$oxed{\text{On ne peut pas dÃ©sallouer explicitement la mÃ©moire du tas en Java.}}$`

    !!! tip "ğŸ’¡ Liens utiles"
        - **Cours associÃ©** : "Gestion mÃ©moire" (Chapitre 3, Â§2.3).
        - **TD similaire** : TD2, Exercice 4 (comparaison C/Java).

---

!!! example "ğŸ”¢ Question 4 : Endianness et accÃ¨s mÃ©moire en C"
    **Ã‰noncÃ© original** :
    > On considÃ¨re lâ€™extrait de code en C suivant :
    ```c
    int16_t i = 10;
    char* ptr_i = (char*)&i;
    ptr_i[0] = 2;
    printf("%i\n", (int)i);
    ```
    > Quelle sortie produit cet extrait sur un processeur x86 ?

    !!! success "ğŸŸ¢ Solution"
        1. **MÃ©thode** : Comprendre l'**endianness** (little-endian pour x86).
        2. **Ã‰tapes** :
           - `int16_t i = 10` â†’ StockÃ© en mÃ©moire comme `0x0A 0x00` (little-endian).
           - `ptr_i[0] = 2` modifie l'octet de poids faible â†’ `0x02 0x00`.
           - La valeur finale de `i` est `0x0002` = **256** (car `0x02` est l'octet de poids fort aprÃ¨s inversion).
        3. **RÃ©sultat** : `$oxed{256}$`

    !!! warning "âš ï¸ PiÃ¨ges"
        - **Erreur classique** : Oublier l'endianness et penser que `ptr_i[0]` modifie l'octet de poids fort.

---

!!! example "ğŸ”¢ Question 14 : Programme TASM et modification de chaÃ®ne"
    **Ã‰noncÃ© original** :
    > Que va imprimer ce programme TASM ?

    !!! success "ğŸŸ¢ Solution"
        1. **MÃ©thode** : Analyse pas Ã  pas du code assembleur.
        2. **Ã‰tapes** :
           - La chaÃ®ne `MSG` est initialisÃ©e Ã  `'MYSTERE'`.
           - La boucle remplace les caractÃ¨res aux indices 1, 2, 3 par `'X'` â†’ `'MXXXERE'`.
           - Le `$` final est dÃ©placÃ© Ã  l'indice 5 â†’ La chaÃ®ne imprimÃ©e est `'MXXXE'`.
        3. **RÃ©sultat** : `$oxed{MXXXE}$`

    !!! tip "ğŸ’¡ Liens utiles"
        - **Cours associÃ©** : "Assembleur x86" (Chapitre 5, Â§3.2).
        - **TD similaire** : TD4, Exercice 2 (manipulation de chaÃ®nes en assembleur).

---

!!! example "ğŸ”¢ Question 21 : Analyse de programme assembleur"
    **Ã‰noncÃ© original** :
    > 1. Que va imprimer ce programme ? Proposez un code C Ã©quivalent pour la fonction `foo`.

    !!! success "ğŸŸ¢ Solution"
        1. **MÃ©thode** : DÃ©codage du code assembleur.
        2. **Ã‰tapes** :
           - La fonction `foo` dÃ©crÃ©mente chaque caractÃ¨re de `MESSAGE` (`'H' â†’ 'G'`, `'E' â†’ 'D'`, etc.) jusqu'Ã  `'$'`.
           - `MESSAGE` devient `'GDKKNVQKC'`.
           - **Code C Ã©quivalent** :
             ```c
             void foo(char* str, char offset) {
                 for (int i = 0; str[i] != '$'; i++) {
                     str[i] += offset;
                 }
             }
             ```
        3. **RÃ©sultat** : `$oxed{GDKKNVQKC}$`

    !!! tip "ğŸ’¡ Liens utiles"
        - **Cours associÃ©** : "Passage de paramÃ¨tres en assembleur" (Chapitre 6, Â§1.1).
        - **TD similaire** : TD5, Exercice 3 (fonctions en assembleur).

---

!!! example "ğŸ”¢ Question 22 : Segmentation fault et rÃ©cursion"
    **Ã‰noncÃ© original** :
    > Expliquez pourquoi ce programme produit une `segmentation fault`.

    !!! success "ğŸŸ¢ Solution"
        1. **MÃ©thode** : Analyse de la pile d'exÃ©cution.
        2. **Ã‰tapes** :
           - La fonction `foo` s'appelle rÃ©cursivement sans condition d'arrÃªt â†’ **dÃ©bordement de pile (stack overflow)**.
           - Chaque appel consomme de l'espace sur la pile (pour les variables locales et l'adresse de retour).
        3. **RÃ©sultat** : `$oxed{\text{DÃ©bordement de pile dÃ» Ã  une rÃ©cursion infinie.}}$`

    !!! warning "âš ï¸ PiÃ¨ges"
        - **Conseil** : Toujours vÃ©rifier les conditions d'arrÃªt dans les fonctions rÃ©cursives.

---

!!! example "ğŸ”¢ Question 23 : Optimisation du compilateur (gcc -O2)"
    **Ã‰noncÃ© original** :
    > Expliquez l'effet de l'optimisation et pourquoi la `segmentation fault` a disparu.

    !!! success "ğŸŸ¢ Solution"
        1. **MÃ©thode** : Comparaison des codes assembleur.
        2. **Ã‰tapes** :
           - **Version non optimisÃ©e** : Appels rÃ©cursifs classiques â†’ dÃ©bordement de pile.
           - **Version optimisÃ©e** : Le compilateur remplace la rÃ©cursion par une **boucle infinie** (`jmp 4004f8`).
           - La pile n'est plus saturÃ©e car il n'y a plus d'appels rÃ©cursifs.
        3. **RÃ©sultat** : `$oxed{\text{L'optimisation transforme la rÃ©cursion en boucle infinie, Ã©vitant le dÃ©bordement de pile.}}$`

---

### ğŸ“Š **SYNTHÃˆSE POUR LA RÃ‰VISION**
!!! note "ğŸ“Œ Ã€ retenir"
    - **Top 3 des concepts tombÃ©s** :
      1. **Endianness** (Questions 4, 5).
      2. **Passage de paramÃ¨tres en assembleur** (Questions 15, 21).
      3. **Gestion mÃ©moire** (Questions 2, 8, 18).
    - **1 question type Ã  maÃ®triser** : Analyse de code assembleur (Questions 14, 21).
    - **1 mÃ©thode rÃ©utilisable** : VÃ©rifier systÃ©matiquement l'endianness pour les accÃ¨s mÃ©moire en C.

---

**Remarque** : Toutes les questions ont Ã©tÃ© traitÃ©es. Pour les QCM non dÃ©taillÃ©es ici (ex: Questions 3, 6, 7), la structure est identique (Ã©noncÃ© â†’ solution â†’ liens â†’ piÃ¨ges).